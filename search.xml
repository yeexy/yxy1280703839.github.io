<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>时间模块</title>
      <link href="/2019/07/29/day20-%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/07/29/day20-%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中有关时间的模块。</p><a id="more"></a><h2 id="day20-时间模块"><a href="#day20-时间模块" class="headerlink" title="day20-时间模块"></a>day20-时间模块</h2><hr><h3 id="一、time模块"><a href="#一、time模块" class="headerlink" title="一、time模块"></a>一、time模块</h3><hr><h4 id="1-包的使用"><a href="#1-包的使用" class="headerlink" title="1.包的使用"></a>1.包的使用</h4><ul><li>1)导入包中的模块<ul><li>from 包名 import 模块名</li><li>from 包名.模块名 import *(或内容)</li></ul></li><li>2)普通文件和包的区别<ul><li>包有一个默认的py文件，文件名是<code>&#39;__init__&#39;</code>，不管用什么方式去导入包中的内容，这个默认文件都会被导入</li></ul></li></ul><hr><h4 id="2-time模块-提供和时间操作相关的函数"><a href="#2-time模块-提供和时间操作相关的函数" class="headerlink" title="2.time模块 - 提供和时间操作相关的函数"></a>2.time模块 - 提供和时间操作相关的函数</h4><ul><li>1)<code>asctime()</code>：获取当前时间，并且以’星期 月份 日期 时:分:秒 年份’的格式返回</li><li>2)<code>localtime()</code>：获取当地的当前时间，返回结构体时间对象</li><li>3)<code>time()</code>：获取当前时间，返回时间戳<ul><li>时间戳：当前时间到格林威治时间的1970年1月1日00时00分00秒的时间差(单位是秒)</li><li>特点：a.方便对时间加密；b.可以节约存储空间</li><li><code>%H：24小时制的时；%I：12小时制的时；%w：星期几</code></li></ul></li><li>4)<code>strftime(时间格式,结构体时间对象)</code>：将时间对象以指定的格式转换成字符串时间</li><li>5)<code>strptime(时间字符串,时间格式)</code>：将字符串时间转换成结构体时间对象</li></ul><hr><h4 id="二、datetime模块"><a href="#二、datetime模块" class="headerlink" title="二、datetime模块"></a>二、datetime模块</h4><hr><h4 id="1-各种时间类"><a href="#1-各种时间类" class="headerlink" title="1.各种时间类"></a>1.各种时间类</h4><ul><li>time类：和时、分、秒、毫秒相关的时间</li><li>date类：和年、月、日相关的时间</li><li>datetime类：和time类、date类都相关的时间</li><li>timedelta：用来时间的加减操作类</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> time </tag>
            
            <tag> Datetime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元组字典和集合</title>
      <link href="/2019/07/29/day8-%E5%85%83%E7%BB%84%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"/>
      <url>/2019/07/29/day8-%E5%85%83%E7%BB%84%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的元组、字典和集合三种数据类型。</p><a id="more"></a><h2 id="day8-元组字典和集合"><a href="#day8-元组字典和集合" class="headerlink" title="day8-元组字典和集合"></a>day8-元组字典和集合</h2><hr><h3 id="一、元组"><a href="#一、元组" class="headerlink" title="一、元组"></a>一、元组</h3><hr><h4 id="1-什么是元组-tuple"><a href="#1-什么是元组-tuple" class="headerlink" title="1. 什么是元组(tuple)"></a>1. 什么是元组(tuple)</h4><ul><li>容器型数据类型</li><li>特点：不可变(不支持增删改)、有序(支持下标操作)</li><li>将()作为容器标志，多个元素用,隔开。元素的要求和列表一样</li></ul><hr><h4 id="2-查询-和列表一样"><a href="#2-查询-和列表一样" class="headerlink" title="2. 查询 - 和列表一样"></a>2. 查询 - 和列表一样</h4><ul><li>注意：元组切片的结果还是元组</li></ul><hr><h4 id="3-相关运算-和列表一样"><a href="#3-相关运算-和列表一样" class="headerlink" title="3. 相关运算 - 和列表一样"></a>3. 相关运算 - 和列表一样</h4><ul><li>+, *, ==, !=, in/not in, len(), max(), min(), sum()</li><li>tuple(序列) - 将数据转换成元组，所有的序列都可以转换成元组</li></ul><hr><h4 id="4-元组的特殊操作"><a href="#4-元组的特殊操作" class="headerlink" title="4. 元组的特殊操作"></a>4. 元组的特殊操作</h4><ul><li><p>单个元素的元组：在只有一个元素的元组中必须加逗号</p><ul><li><code>tuple1 = (10,)</code></li></ul></li><li><p>如果一个元组有多个元素，元组的括号可以省略</p></li><li><p>获取元素，通过让变量的个数和元组中的元素的个数保持一致来分别获取元组中的元素的值</p><ul><li><blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; tuple1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>&gt; x, y, z = tuple<br>&gt; print(x, y, z)<br>&gt;<br></code></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>可以通过在某一个变量前加<em>来获取不带</em>的变量取完后剩下的所有元素</p><ul><li><p>注意：带*的变量只能有一个，而且这个变量的结果是一个列表</p></li><li><blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; tuple2 = (<span class="hljs-string">'小明'</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)<br>&gt; name, age, *num = tuple2<br>&gt;<br></code></pre></td></tr></table></figure></blockquote></li></ul></li></ul><hr><h3 id="二、字典"><a href="#二、字典" class="headerlink" title="二、字典"></a>二、字典</h3><hr><h4 id="1-什么是字典-dict"><a href="#1-什么是字典-dict" class="headerlink" title="1. 什么是字典(dict)"></a>1. 什么是字典(dict)</h4><ul><li>字典是容器型数据类型</li><li>特点：可变(支持增删改)、无序(不支持下标操作)</li><li>字典容器标志是{}；多个元素用,隔开</li></ul><hr><h4 id="2-字典中的元素"><a href="#2-字典中的元素" class="headerlink" title="2. 字典中的元素"></a>2. 字典中的元素</h4><ul><li>字典中的元素是键值对，以’key:value’的形式存在，而且key和value必须成对出现</li><li>键(key) - 不可变的数据，并且是唯一的(一般使用字符串作为键)</li><li>值(value) - 没有要求(和列表元素要求一样)</li><li>注意：字典保存数据，真正要存储的是值，键只是为了对不同的值进行区分而存在的</li></ul><hr><h4 id="3-查询-获取字典键值对中value的值"><a href="#3-查询-获取字典键值对中value的值" class="headerlink" title="3. 查询 - 获取字典键值对中value的值"></a>3. 查询 - 获取字典键值对中value的值</h4><ul><li><p>获取单个值</p><ul><li>字典[key]：获取字典中指定key对应的值(key不存在会报错)</li><li>字典.get(key)：获取字典中key对应的值(key不存在不会报错而是返回None)</li><li>字典.get(key, 默认值)：获取字典中key对应的值(key不存在不会报错而是返回默认值)</li></ul></li><li><p>遍历获取值</p><ul><li><blockquote><p>for 变量 in 字典:</p><p>​    循环体</p><p>变量取到的是字典中所有的key</p></blockquote></li></ul></li></ul><hr><h4 id="4-字典相关操作：增-改-删"><a href="#4-字典相关操作：增-改-删" class="headerlink" title="4. 字典相关操作：增/改, 删"></a>4. 字典相关操作：增/改, 删</h4><ul><li>增 - 添加键值对；改 - 修改某个key对应的值<ul><li>字典[key] = 值 - 当key不存在就是增加，当key存在就是修改</li></ul></li><li>删除 - 删除键值对<ul><li>del 字典[key] - 删除字典中指定key对应的键值对</li><li>字典.pop(key) - 取出字典中指定key对应的值，返回取出的值</li></ul></li></ul><hr><h4 id="5-字典相关运算"><a href="#5-字典相关运算" class="headerlink" title="5. 字典相关运算"></a>5. 字典相关运算</h4><ul><li>比较相等：==, !=</li><li>in/not in：key in 字典 - 判断key值是否存在字典中</li><li><code>len()</code>：获取字典的长度</li><li><code>dict()</code>：转换成字典类型<ul><li>能转换成字典的数据：本身必须是一个序列，序列中元素还是一个小序列，而且小序列中必须只有两个元素</li><li>注意：将字典转换成列表、元组、集合时将字典的key作为元素</li></ul></li></ul><hr><h4 id="6-字典相关函数"><a href="#6-字典相关函数" class="headerlink" title="6. 字典相关函数"></a>6. 字典相关函数</h4><ul><li><code>字典.clear()</code> - 清空字典</li><li><code>字典.copy()</code> - 复制字典中所有的键值对，产生一个新的字典</li><li><code>dict.fromkeys(序列, 值)</code> - 创建一个字典，将序列中元素作为value，返回一个字典<ul><li>如果没有值，则返回None</li></ul></li><li><code>items()</code> - 同时获取字典中所有的key和value，以序列的形式返回，序列中的元素是(key, value)元组</li><li><code>keys()</code> - 获取字典中所有的key，以序列的形式返回</li><li><code>values</code> - 获取字典中所有的value，以序列的形式返回</li><li><code>字典.setdefault(key, value)</code> - 添加键值对，key不存在时添加，key存在时不修改</li><li><code>字典.update(序列)</code> - 用序列去更新字典，这个序列必须是字典或可以转换成字典的序列</li></ul><hr><h3 id="三、集合"><a href="#三、集合" class="headerlink" title="三、集合"></a>三、集合</h3><hr><h4 id="1-什么是集合-set"><a href="#1-什么是集合-set" class="headerlink" title="1. 什么是集合(set)"></a>1. 什么是集合(set)</h4><ul><li>容器型数据类型</li><li>特点：可变(支持增删改)、无序(不支持下标操作)</li><li>将{}作为容器的标志；里面的元素用,隔开</li><li>空集合：set()</li></ul><hr><h4 id="2-集合中的元素"><a href="#2-集合中的元素" class="headerlink" title="2. 集合中的元素"></a>2. 集合中的元素</h4><ul><li>元素不可变：列表、字典、集合不能作为集合的元素</li><li>元素唯一：(自带去重功能)利用元素的唯一性去重</li></ul><hr><h4 id="3-集合的增删改查"><a href="#3-集合的增删改查" class="headerlink" title="3. 集合的增删改查"></a>3. 集合的增删改查</h4><ul><li>查询 - 集合不能单独取出一个元素，只能通过遍历一个一个的取出所有的元素</li><li>增加<ul><li><code>集合.add()</code> - 在集合中添加一个元素</li><li><code>集合.update(序列)</code> - 将序列中的元素添加到集合中(序列中的元素必须不可变)</li></ul></li><li><code>删除 - 集合.remove(元素)</code>：删除集合中指定的元素</li><li>改 - 集合不支持改操作</li></ul><hr><h4 id="4-数学集合运算"><a href="#4-数学集合运算" class="headerlink" title="4. 数学集合运算"></a>4. 数学集合运算</h4><ul><li>并集(|)：将两个集合中的元素合并并产生一个新的集合</li><li>交集(&amp;)：将两个集合公共的元素取出来产生一个新的集合</li><li>对称差集(^)：获取两个集合除了公共部分剩下的部分</li><li>差集(-)：(集合1-集合2)集合1除了和集合2公共的部分剩下的元素</li><li>集合1 &gt; 集合2：判断集合1中是否包含集合2</li><li>集合1 &lt; 集合2：判断集合2中是否包含集合1</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元组 </tag>
            
            <tag> 字典 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础</title>
      <link href="/2019/07/27/day19-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/07/27/day19-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的多线程基础，了解什么是进程，什么是线程。</p><a id="more"></a><h2 id="day19-多线程基础"><a href="#day19-多线程基础" class="headerlink" title="day19-多线程基础"></a>day19-多线程基础</h2><hr><h3 id="一、多线程理论"><a href="#一、多线程理论" class="headerlink" title="一、多线程理论"></a>一、多线程理论</h3><hr><h4 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1. 什么是进程"></a>1. 什么是进程</h4><ul><li>指系统中正在运行的一个程序</li><li>特点：每个进程是独立的，每个进程均运行在其专用且受保护的内存空间</li></ul><hr><h4 id="2-什么是线程"><a href="#2-什么是线程" class="headerlink" title="2. 什么是线程"></a>2. 什么是线程</h4><ul><li>一个进程要想执行任务，必须得有线程(每个进程至少要有一条线程)</li><li>一个进程的所有任务都在线程中执行</li><li>线程的串行：<ul><li>一个线程中任务的执行是串行的</li><li>同一时间一个线程只能执行一个任务</li></ul></li></ul><hr><h4 id="3-进程和线程的比较"><a href="#3-进程和线程的比较" class="headerlink" title="3. 进程和线程的比较"></a>3. 进程和线程的比较</h4><ul><li>1)线程是cpu调用的最小单位</li><li>2)进程是cpu分配资源和调度的单位</li><li>3)一个程序可以对应多个进程，一个进程中可以有多个线程，但至少要有有一个线程</li><li>4)同一进程内的线程共享进程的资源</li></ul><hr><h4 id="4-什么是多线程"><a href="#4-什么是多线程" class="headerlink" title="4. 什么是多线程"></a>4. 什么是多线程</h4><ul><li>定义：一个进程中可以开启多条线程，每条线程可以并行执行不同的任务</li><li>作用：多线程技术可以提高程序的执行效率</li><li>原理：<ul><li>同一时间，cpu只能处理一条线程，只有一条线程在工作</li><li>多线程并发执行，其实就是cpu快速的在多条线程之间的调度</li><li>如果cpu调度线程时间足够快，就造成了多线程并发执行的假象</li></ul></li></ul><hr><h3 id="二、多线程技术"><a href="#二、多线程技术" class="headerlink" title="二、多线程技术"></a>二、多线程技术</h3><hr><h4 id="1-主线程和子线程"><a href="#1-主线程和子线程" class="headerlink" title="1. 主线程和子线程"></a>1. 主线程和子线程</h4><ul><li>默认情况下，进程有一个线程，这个线程叫主线程。(主线程是自动创建的)</li><li>默认情况下所有的代码都是在主线程中执行的</li><li>程序员通过代码创建的线程都叫子线程。</li></ul><hr><h4 id="2-创建子线程"><a href="#2-创建子线程" class="headerlink" title="2. 创建子线程"></a>2. 创建子线程</h4><ul><li>python内置的threading模块中提供了和线程操作相关的类和方法</li><li>threading模块中有个Thread类，这个类或者这个的子类的对象就是线程对象</li><li>需要子线程的时候就创建Thread类的对象</li><li>1)创建线程对象<ul><li>语法：<code>Thread(target=函数, args=实参列表) - 返回子线程对象</code></li><li>说明：target-必须要赋一个函数，这个函数会在子线程中调用</li><li>args-赋一个元组，元组中的元素就是调用target函数的时候需要传的参数</li></ul></li><li>2)让子线程开始执行<ul><li>线程对象.start()-在子线程中去调用target对应的download，并且将args中的值作为实参</li></ul></li><li>3)程序的结束(进程的结束)<ul><li>一个进程是否结束，看这个进程中是否每个线程都结束</li><li>线程结束：任务执行完成自然死亡、遇到exit()函数、发生异常</li><li>程序出现异常只会影响一个线程，线程中遇到exit()，线程直接结束</li></ul></li></ul><hr><h4 id="3-通过创建Thread类的子类对象来创建子线程"><a href="#3-通过创建Thread类的子类对象来创建子线程" class="headerlink" title="3. 通过创建Thread类的子类对象来创建子线程"></a>3. 通过创建Thread类的子类对象来创建子线程</h4><ul><li>1)声明一个类继承Thread</li><li>2)实现run方法，这个方法中的代码就是会在子线程中执行的代码</li><li>3)创建子类的线程对象</li><li>4)通过start去执行子线程中的任务</li></ul><hr><h4 id="4-join-方法"><a href="#4-join-方法" class="headerlink" title="4. join()方法"></a>4. join()方法</h4><ul><li><blockquote><p>线程对象.join()</p><p>其他对象</p><p>说明：这儿的其他代码会等到线程对象结束后才会执行</p></blockquote></li></ul><hr><h4 id="5-多线程数据安全问题"><a href="#5-多线程数据安全问题" class="headerlink" title="5. 多线程数据安全问题"></a>5. 多线程数据安全问题</h4><ul><li>通过加锁来解决数据安全问题</li><li>1)保证一个数据对应一把锁：创建锁的对象</li><li>2)在使用数据之前，加锁：锁对象.acquire()</li><li>3)数据使用完后，释放锁：锁对象.release()</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 多线程技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2019/07/25/day18-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/07/25/day18-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的网络编程技术，什么是socket套接字以及requests的使用。</p><a id="more"></a><h2 id="day18-网络编程"><a href="#day18-网络编程" class="headerlink" title="day18-网络编程"></a>day18-网络编程</h2><hr><h3 id="一、socket服务器"><a href="#一、socket服务器" class="headerlink" title="一、socket服务器"></a>一、socket服务器</h3><hr><h4 id="1-什么是socket"><a href="#1-什么是socket" class="headerlink" title="1. 什么是socket"></a>1. 什么是socket</h4><ul><li>socket又叫套接字，指的是实现网络通信的两端</li></ul><hr><h4 id="2-服务器套接字"><a href="#2-服务器套接字" class="headerlink" title="2. 服务器套接字"></a>2. 服务器套接字</h4><ul><li><p>1)创建套接字对象</p><ul><li><p><code>server = socket.socket()</code></p></li><li><blockquote><p>socket(family=AF_INET, type=SOCK_STREAM)</p><p>family：设置ip类型；AF_INET：ipv4；AF_INET6：ipv6</p><p>type：设置传输协议类型；SOCK_STREAM：TCP传输协议；SOCK_DGRAM：UDP传输协议</p></blockquote></li></ul></li><li><p>2)绑定IP和端口</p><ul><li><p><code>server.bind((&#39;10.7.160.57&#39;, 1234))</code></p></li><li><blockquote><p>bind(address)：绑定地址</p><p>address：元组(IP地址，端口)</p><p>ip地址：通过ip地址可以确定互联网中唯一的一台计算机(字符串)，运行服务器程序的计算机的ip地址</p><p>端口：端口是用来区分同一台计算机中的不同服务，范围是0-65535，其中0-1024是著名端口，不能随便使用</p></blockquote></li></ul></li><li><p>3)开始监听，同时设置最大在线客户端个数(设置同时在线人数)</p><ul><li>server.listen(200)</li></ul></li><li><p>4)让服务器一直处于启动状态(通过死循环方式)</p></li><li><p>5)接收请求，返回建立的连接和客户端的地址</p><ul><li><code>connection, addr = server.accept()</code></li><li>注意：当代码执行到这里的时候，会阻塞线程</li></ul></li><li><p>6)接收客户端发送的消息</p><ul><li><p><code>re_data = connection.recv(1024)</code></p></li><li><p>recv(一次性能够接收的最大值)：返回值是接收到的数据，类型是二进制</p></li><li><p><code>re_message = re_data.decode(encoding=&#39;utf-8&#39;)</code></p></li><li><blockquote><p>二进制数据和字符串的转换</p><p>a.二进制转字符串：</p><p>-str(二进制数据, encoding=’utf-8’)</p><p>-二进制.decode(encoding=’utf-8’)</p><p>b.字符串转二进制：</p><p>-bytes(字符串, 编码方式)</p><p>-字符串.encode()</p></blockquote></li></ul></li><li><p>7)发送消息</p><ul><li><code>connection.send(&#39;hello&#39;.encode())</code></li></ul></li><li><p>8)关闭连接</p><ul><li><code>connection.close()</code></li></ul></li></ul><hr><h3 id="二、socket客户端"><a href="#二、socket客户端" class="headerlink" title="二、socket客户端"></a>二、socket客户端</h3><hr><h4 id="1-客户端套接字"><a href="#1-客户端套接字" class="headerlink" title="1.客户端套接字"></a>1.客户端套接字</h4><ul><li>1)创建套接字对象<ul><li><code>client = socket.socket()</code></li></ul></li><li>2)直接连接服务器<ul><li><code>client.connect((&#39;10.7.160.57&#39;, 8000))</code></li><li>connect((服务器地址, 服务器端口))</li></ul></li><li>3)发送消息<ul><li><code>client.send(&#39;hello&#39;.encode())</code></li></ul></li><li>4)接收消息<ul><li><code>re_data = client.recv(1024)</code></li><li><code>re_message = re_data.decode(encoding=&#39;utf-8&#39;)</code></li></ul></li><li>5)关闭连接<ul><li><code>client.close()</code></li></ul></li></ul><hr><h3 id="三、requests的使用"><a href="#三、requests的使用" class="headerlink" title="三、requests的使用"></a>三、requests的使用</h3><hr><h4 id="1-requests"><a href="#1-requests" class="headerlink" title="1.requests"></a>1.requests</h4><ul><li>requests是一个专门用来支持HTTP请求的一个第三方库</li><li>1)获取指定url对应的资源，返回时响应<ul><li><code>response = requests.get(url)</code></li><li><code>response = requests.post(url)</code></li></ul></li><li>2)获取响应头<ul><li><code>response.headers</code></li></ul></li><li>3)获取内容<ul><li>a.字符串格式的内容<ul><li><code>response.text</code></li></ul></li><li>b.获取json内容<ul><li><code>response.json()</code></li></ul></li><li>c.获取二进制内容<ul><li><code>data = response.content</code></li></ul></li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> Socket </tag>
            
            <tag> requests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/07/23/day17-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/07/23/day17-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中正则表达式和re模块部分。</p><a id="more"></a><h2 id="day17-正则表达式"><a href="#day17-正则表达式" class="headerlink" title="day17-正则表达式"></a>day17-正则表达式</h2><hr><h3 id="一、正则符号"><a href="#一、正则符号" class="headerlink" title="一、正则符号"></a>一、正则符号</h3><hr><h4 id="1-什么是正则"><a href="#1-什么是正则" class="headerlink" title="1. 什么是正则"></a>1. 什么是正则</h4><ul><li>正则是字符串匹配的一种工具，拥有自己的语法。语法中主要包含各种符号的使用</li><li>re中主要提供正则相关的方法</li></ul><hr><h4 id="2-正则语法"><a href="#2-正则语法" class="headerlink" title="2. 正则语法"></a>2. 正则语法</h4><ul><li><p>python中的正则表达式是写在引号中(可以是单引号也可以是双引号)，但是一般情况下会在引号前面加r(r’正则表达式’)</p><h5 id="2-1-匹配符号"><a href="#2-1-匹配符号" class="headerlink" title="2.1 匹配符号"></a>2.1 匹配符号</h5></li><li><p>1)普通字符</p><ul><li>除了正则中有特殊功能和特殊意义以外的其他所有的字符</li><li>普通字符在正则中表示字符本身</li></ul></li><li><p>2) .  -  匹配任意字符</p><ul><li>正则中出现.的位置可以匹配任意字符，除了’\n’</li><li>一个.只能匹配一个任意字符</li></ul></li><li><p>3) \w  -  匹配字母、数字或下划线(只针对ASCII码有效)</p><ul><li>一个\w只能匹配一个字符</li><li>注意：Unicode码中除了ASCII表以外的其他字符都能匹配</li></ul></li><li><p>4) \s  -  匹配一个空白字符</p><ul><li>空白：空格、回车、换行、制表符(\t、\n、\r、\v、\f)</li></ul></li><li><p>5) \d  -  匹配一个数字字符</p></li><li><p>6) \大写字母  -  匹配非\小写字母匹配到的内容</p><ul><li>\W：匹配非数字、字母、下划线字符</li><li>\S：匹配非空白字符</li><li>\D：匹配非数字字符</li></ul></li><li><p>7) []  -  匹配字符集</p><ul><li>a.普通用法<ul><li>[字符集]：匹配字符集中的任意一个字符</li></ul></li><li>b.表示范围的字符集<ul><li>[字符1-字符2]：从字符1到字符2中的任意一个字符</li><li>注意：字符2的编码值必须大于字符1</li></ul></li><li>c.反向选中<ul><li>[^字符集]：选中除了字符集以外的其他任意一个字符<h5 id="2-2-检测符号"><a href="#2-2-检测符号" class="headerlink" title="2.2 检测符号"></a>2.2 检测符号</h5></li></ul></li></ul></li><li><p>一个匹配符号必须对应一个具体的字符；检测符号只是对符号所在的位置进行检查，不会影响字符串长度</p></li><li><p>1) \b  -  检测是否是单词边界</p><ul><li>单词边界：一切可以将两个单词区分开的符号都是单词边界，例如：单词开头、单词结尾、空白、标点符号等</li></ul></li><li><p>2) ^  -  检测^所在的位置是否是字符开头</p></li><li><p>3) <code>$</code>  -  检测<code>$</code>所在的位置是否是字符串结尾</p></li></ul><h5 id="2-3-匹配次数"><a href="#2-3-匹配次数" class="headerlink" title="2.3 匹配次数"></a>2.3 匹配次数</h5><ul><li>1) *  -  匹配0次或无限次<ul><li>字符<code>*</code>：*前的字符出现0次或无限次</li></ul></li><li>2) +  -  匹配1次或无限次<ul><li>字符+：+前的字符出现1次或无限次</li></ul></li><li>3) ?  -  匹配0次或1次<ul><li>字符?：?前的字符出现0次或1次</li></ul></li><li>4) {}语法<ul><li>{N}：匹配N次</li><li>{M,N}：匹配M到N次</li><li>{M,}：匹配至少M次</li><li>{,N}：匹配至多N次</li></ul></li></ul><hr><h4 id="3-贪婪和非贪婪"><a href="#3-贪婪和非贪婪" class="headerlink" title="3. 贪婪和非贪婪"></a>3. 贪婪和非贪婪</h4><ul><li>*,+,?,{}对应的匹配次数是贪婪的</li><li>在匹配次数不确定的时候才有贪婪和非贪婪的分区</li><li>在匹配不确定的符号后面加?,就会变成非贪婪：*?, +?, ??, {M,N}?, {M,}?, {,N}?</li><li>贪婪：在匹配成功的前提下，尽可能多的匹配</li><li>非贪婪：在匹配成功的前提下，尽可能少的匹配</li></ul><hr><h4 id="4-分支结构"><a href="#4-分支结构" class="headerlink" title="4. 分支结构"></a>4. 分支结构</h4><ul><li>正则表达式1|正则表达式2</li></ul><hr><h4 id="5-分组"><a href="#5-分组" class="headerlink" title="5. () - 分组"></a>5. () - 分组</h4><ul><li>1)分组：将正则中的一部分看成一个整体进行操作</li><li>2)重复：添加分组后，可以在分组的后面通过’\M’来重复前面第M个分组匹配到的结果</li></ul><hr><h4 id="6-转义字符"><a href="#6-转义字符" class="headerlink" title="6. 转义字符"></a>6. 转义字符</h4><ul><li>在正则符号前加\，然后让符号的功能消失</li><li>独立的特殊符号是放在[]中特殊意义会自动消失，但是-,[]…</li><li>正则中的转义字符和字符串的转义字符是两回事</li></ul><hr><h3 id="二、re，模块"><a href="#二、re，模块" class="headerlink" title="二、re，模块"></a>二、re，模块</h3><hr><h4 id="1-创建正则对象-compile"><a href="#1-创建正则对象-compile" class="headerlink" title="1. 创建正则对象 - compile()"></a>1. 创建正则对象 - compile()</h4><ul><li>先要<code>from re import *</code></li><li><code>compile(正则表达式)</code>：根据正则表达式创建正则对象</li></ul><hr><h4 id="2-匹配"><a href="#2-匹配" class="headerlink" title="2. 匹配"></a>2. 匹配</h4><ul><li><code>fullmatch(正则表达式,字符串)</code>：让整个字符串和正则表达式进行匹配</li><li><code>match(正则表达式,字符串)</code>：匹配字符串开头</li><li>返回值：匹配成功是结果对象，匹配失败是None</li><li>匹配结果：1)匹配结果对应的字符串<ul><li>匹配对象.group()：获取整个正则匹配到结果</li><li>匹配对象.group(N)：获取第N个分组匹配到的结果</li></ul></li><li>2)获取匹配位置<ul><li>匹配对象.span(group=0)</li><li>匹配对象.start(group=0)</li><li>匹配对象.end(group=0)</li></ul></li><li>3)获取原字符串<ul><li>匹配对象.string</li></ul></li></ul><hr><h4 id="3-查找"><a href="#3-查找" class="headerlink" title="3. 查找"></a>3. 查找</h4><ul><li><code>search(正则表达式,字符串)</code>：匹配出字符串中第一个满足正则表达式的子串，结果是匹配对象</li><li><code>findall(正则表达式,字符串)</code>：获取字符串中所有满足正则表达式的子串；结果是列表，列表中元素是字符串</li><li><code>finditer(正则表达式,字符串)</code>：获取字符中满足正则表达式的所有的子串；结果是迭代器，迭代器中的元素是匹配对象</li></ul><hr><h4 id="4-切割"><a href="#4-切割" class="headerlink" title="4. 切割"></a>4. 切割</h4><ul><li><code>split(正则表达式,字符串)</code>：将字符串按照满足正则表达式的子串进行切割，返回列表</li></ul><hr><h4 id="5-替换"><a href="#5-替换" class="headerlink" title="5. 替换"></a>5. 替换</h4><ul><li><code>sub(正则表达式,字符串1,字符串2,替换次数=0)</code>：将字符串2满足正则表达式的子串替换为字符串1，替换次数为0时就是全部替换</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> re模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理和拷贝</title>
      <link href="/2019/07/21/day16-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/07/21/day16-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中有关内存管理以及浅拷贝、深拷贝的问题。</p><a id="more"></a><h2 id="day16-内存管理和拷贝"><a href="#day16-内存管理和拷贝" class="headerlink" title="day16-内存管理和拷贝"></a>day16-内存管理和拷贝</h2><hr><h3 id="一、多继承"><a href="#一、多继承" class="headerlink" title="一、多继承"></a>一、多继承</h3><hr><h4 id="1-多继承"><a href="#1-多继承" class="headerlink" title="1. 多继承"></a>1. 多继承</h4><ul><li>python中的类支持多继承</li><li>class 子类(父类1,父类2,…)</li><li>多继承只能继承第一个父类的对象属性</li></ul><hr><h3 id="二、运算符重载"><a href="#二、运算符重载" class="headerlink" title="二、运算符重载"></a>二、运算符重载</h3><hr><h4 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. 运算符</h4><ul><li>python中所有的数据类型本质都是类，所有的数据本质都是对象</li><li>在使用运算符对数据进行操作的时候，实质是在调用运算符对应的魔法方法，运算符前面的数据类型，决定了函数调用哪个类中对应的魔法方法</li><li>每个运算符都有自己固定的魔法方法，看某种类型的数据是否支持某种运算符就看这个类型中有没有实现对应的魔法方法</li><li>注意：&gt;和&lt;符号只需要重载一个，另外一个自动支持</li></ul><hr><h3 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h3><hr><h4 id="手动内存管理"><a href="#手动内存管理" class="headerlink" title="手动内存管理"></a>手动内存管理</h4><ul><li>内存分为栈区间和堆区间，栈区间中的内存是自动开辟自动释放的；堆里的内存需要程序员写代码申请和释放</li></ul><h4 id="1-内存的开辟"><a href="#1-内存的开辟" class="headerlink" title="1. 内存的开辟"></a>1. 内存的开辟</h4><ul><li>python中所有的类型都是类，所以所有的数据都是对象。对象都是保存在堆区间；变量是保存在栈区间，变量中实际保存的堆中存储的数据的地址。(变量的本质就是指针)</li><li>注意：除了数字和字符串对象，其他数据都是每次需要的时候直接在堆中开辟区间。数字和字符串会先检查这个数据之前是否保存过，如果保存过就直接用之前的数据，否则才开辟新的空间。</li></ul><hr><h4 id="2-内存的释放"><a href="#2-内存的释放" class="headerlink" title="2. 内存的释放"></a>2. 内存的释放</h4><ul><li>python中内存的释放采用的是’垃圾回收机制’自动释放</li><li>垃圾回收机制原理：<ul><li>1)看一个数据是否需要销毁(回收)，就看这个对象的引用计数是否为0(引用：保存对象地址的数据)</li><li>2)如果这个对象引用计数不为0就假设当前对象消失，然后看会不会有其他对象因为它的消失引用计数变为0，如果有，就将另外一个对象也回收(循环引用释放)</li></ul></li><li>注意：用一个变量给另外一个变量赋值实质上赋的是地址</li><li>==和is的区别：==(判断的是值是否相等)；is(判读的是地址是否相等)</li></ul><hr><h3 id="四、浅拷贝和深拷贝"><a href="#四、浅拷贝和深拷贝" class="headerlink" title="四、浅拷贝和深拷贝"></a>四、浅拷贝和深拷贝</h3><hr><h4 id="1-使用变量的3种情况"><a href="#1-使用变量的3种情况" class="headerlink" title="1. 使用变量的3种情况"></a>1. 使用变量的3种情况</h4><ul><li>1)直接赋值：赋的是地址，赋完值后两个变量一模一样</li><li>2)浅拷贝：列表[:]、列表.copy()、copy.copy()<ul><li>直接复制被拷贝的数据，产生一个新的地址，将新的地址赋值给变量；</li><li>如果被拷贝的对象有子对象，子对象不会被赋值</li></ul></li><li>3)深拷贝：<code>copy.deepcopy()</code><ul><li>直接复制被拷贝的数据，产生一个新的地址，将新的地址赋值给变量；</li><li>如果被拷贝的对象有子对象，子对象也会被赋值</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浅拷贝和深拷贝 </tag>
            
            <tag> 内存管理机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象2</title>
      <link href="/2019/07/19/day15-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A12/"/>
      <url>/2019/07/19/day15-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A12/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中类方法和静态方法、私有属性、getter和setter以及继承。</p><a id="more"></a><h2 id="day15-类和对象2"><a href="#day15-类和对象2" class="headerlink" title="day15-类和对象2"></a>day15-类和对象2</h2><hr><h3 id="一、类方法和静态方法"><a href="#一、类方法和静态方法" class="headerlink" title="一、类方法和静态方法"></a>一、类方法和静态方法</h3><hr><h4 id="1-类中的方法"><a href="#1-类中的方法" class="headerlink" title="1. 类中的方法"></a>1. 类中的方法</h4><ul><li>1)对象方法<ul><li>a.怎么声明：直接声明在类中的函数</li><li>b.怎么调用：通过对象来调用，以’对象.方法名()’方式调用</li><li>c.特点：有一个指向当前对象的默认参数self；调用的时候不需要传参</li><li>d.什么时候用：实现函数的功能需要用到对象属性，就只能用对象方法</li></ul></li><li>2)类方法<ul><li>a.怎么声明：声明函数前加‘@classmethod’</li><li>b.怎么调用：通过类来调用，以’类.方法名()’方式调用</li><li>c.特点：有一个默认参数cls，在通过类调用的时候不需要传参；指向当前类，类能做的事情，cls都能做</li><li>d.什么时候用：实现函数的功能不需要对象属性的前提下，需要类的字段(需要类)，就用类方法</li></ul></li><li>3)静态方法<ul><li>a.怎么声明：声明函数前加‘@staticmethod’</li><li>b.怎么调用：通过类来调用，以’类.方法名()’方式来调用</li><li>c.特点：没有特点，没有默认参数</li><li>d.什么时候用：实现函数的功能既不需要对象属性，也不需要类的字段，就用静态方法</li></ul></li></ul><hr><h3 id="二、私有化属性"><a href="#二、私有化属性" class="headerlink" title="二、私有化属性"></a>二、私有化属性</h3><hr><h4 id="1-访问权限-其他语言中"><a href="#1-访问权限-其他语言中" class="headerlink" title="1. 访问权限(其他语言中)"></a>1. 访问权限(其他语言中)</h4><ul><li>公开(public)：属性和方法在类的内部可以使用、可以被继承；也可以在类的外部使用</li><li>保护(protect)：属性和方法在类的内部可以使用、可以被继承；但不能在类的外部使用</li><li>私有(private)：属性和方法在类的内部可以使用；但不能被继承。也不能在类的外部使用</li><li>python中本质上所有的属性和方法都是公开的，私有化是假的私有化</li></ul><hr><h4 id="2-私有化"><a href="#2-私有化" class="headerlink" title="2. 私有化"></a>2. 私有化</h4><ul><li>语法：在声明属性或方法的时候，在属性名前或方法名前加<code>&#39;__&#39;</code>;</li><li>注意：只能以<code>&#39;__&#39;</code>开头，不能以<code>&#39;__&#39;</code>结尾</li><li>私有化原理：只是单纯的在私有属性或方法名前加’_类名’，导致直接使用原名就使用不了属性和方法</li></ul><hr><h3 id="三、getter和setter"><a href="#三、getter和setter" class="headerlink" title="三、getter和setter"></a>三、getter和setter</h3><hr><h4 id="1-什么时候使用getter和setter"><a href="#1-什么时候使用getter和setter" class="headerlink" title="1. 什么时候使用getter和setter"></a>1. 什么时候使用getter和setter</h4><ul><li>1)getter：希望获取一个属性值之前做点别的事情，就给这个属性添加getter</li><li>2)setter：希望给属性赋值之前做点别的事情，就给这个属性添加setter</li></ul><hr><h4 id="2-怎么给属性添加getter和setter"><a href="#2-怎么给属性添加getter和setter" class="headerlink" title="2. 怎么给属性添加getter和setter"></a>2. 怎么给属性添加getter和setter</h4><ul><li>1)怎么添加getter<ul><li>a.在需要添加getter的属性前加一个下划线</li><li>b.在@property后面声明一个函数，函数名和去掉下划线的属性名一致，并且函数需要一个返回值表示获取属性的值</li><li>c.在外面通过不带下划线的属性名去获取对应的属性值</li></ul></li><li>2)怎么添加setter<ul><li>a.如果想要给属性添加setter，必须先给他添加getter</li><li>b.@getter名.setter后面声明函数；函数名和去掉下划线的属性名一致，这个函数不需要返回值，但是需要一个参数</li><li>c.在外面通过不带下划线的属性名去给属性赋值</li></ul></li></ul><hr><h3 id="四、继承"><a href="#四、继承" class="headerlink" title="四、继承"></a>四、继承</h3><hr><h4 id="1-什么是继承"><a href="#1-什么是继承" class="headerlink" title="1. 什么是继承"></a>1. 什么是继承</h4><ul><li>让子类直接拥有父类的属性和方法，这个过程就是继承</li></ul><hr><h4 id="2-怎么继承"><a href="#2-怎么继承" class="headerlink" title="2. 怎么继承"></a>2. 怎么继承</h4><ul><li><p>python中所有的类，默认都是继承自object(object是基类)</p></li><li><p>1)语法：</p><ul><li><blockquote><p>class 类名(父类1，父类2，…)：</p><p>​    类的内容</p><p>继承发生后子类直接拥有父类的所有的属性和方法(除了<code>__slots__</code>魔法)</p></blockquote></li></ul></li></ul><hr><h4 id="3-子类添加内容"><a href="#3-子类添加内容" class="headerlink" title="3. 子类添加内容"></a>3. 子类添加内容</h4><ul><li><p>1)添加字段和方法</p><ul><li>直接在子类中声明新的字段或方法</li></ul></li><li><p>2)添加对象属性</p><ul><li>需要继承父类的<code>__init__</code>方法</li></ul></li><li><p>补充：1)类中的函数的调用：</p><ul><li><blockquote><p>先看当前类中有没有这个方法，如果有直接调用，如果没有就看父类有没有这个方法；有的话就调用，如果没有就看父类的父类有没有这个方法…以此类推，如果找到基类都没有，程序才会报错</p></blockquote></li></ul></li><li><p>补充：2)super()的使用：</p><ul><li>在子类的对象方法和类方法中都可以通过super()去调用父类的对象方法和类方法；</li><li>在子类中的静态方法中不能使用super()</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> getter和setter </tag>
            
            <tag> 继承 </tag>
            
            <tag> 类方法和静态方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象1</title>
      <link href="/2019/07/17/day14-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A11/"/>
      <url>/2019/07/17/day14-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A11/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中面向对象的编程思想以及方法。</p><a id="more"></a><h2 id="day14-类和对象1"><a href="#day14-类和对象1" class="headerlink" title="day14-类和对象1"></a>day14-类和对象1</h2><hr><h3 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h3><hr><h4 id="1-编程思想"><a href="#1-编程思想" class="headerlink" title="1. 编程思想"></a>1. 编程思想</h4><ul><li>面向过程编程：算法和逻辑</li><li>函数式编程：函数</li><li>面向对象编程：类和对象</li></ul><hr><h3 id="二、类和对象"><a href="#二、类和对象" class="headerlink" title="二、类和对象"></a>二、类和对象</h3><hr><h4 id="1-什么是类，什么是对象"><a href="#1-什么是类，什么是对象" class="headerlink" title="1. 什么是类，什么是对象"></a>1. 什么是类，什么是对象</h4><ul><li>类就是拥有相同功能和相同属性的对象的集合：类是抽象的</li><li>对象就是类的实例：对象是具体</li></ul><hr><h4 id="2-类的声明"><a href="#2-类的声明" class="headerlink" title="2. 类的声明"></a>2. 类的声明</h4><ul><li><p>1)语法</p><ul><li><blockquote><p>class 类名：</p><p>​    类的内容</p></blockquote></li></ul></li><li><p>2)说明</p><ul><li><blockquote><p>class：关键字</p><p>类名：程序员自己命名的；是标识符但不能是关键字(要求)</p><p>a.采用驼峰式命名，并且首字母大写</p><p>b.见名知义</p><p>类的内容：包含类的说明文档、类中的函数(相同的功能)、类中的属性(相同的属性)</p></blockquote></li></ul></li></ul><hr><h4 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3. 创建对象"></a>3. 创建对象</h4><ul><li>语法：对象 = 类()</li><li>同一个类可以创建多个对象</li></ul><hr><h3 id="三、对象方法"><a href="#三、对象方法" class="headerlink" title="三、对象方法"></a>三、对象方法</h3><hr><h4 id="1-类中的函数"><a href="#1-类中的函数" class="headerlink" title="1. 类中的函数"></a>1. 类中的函数</h4><ul><li>声明在类中的函数又叫方法，类中的方法分为三种：对象方法、类方法、静态方法</li><li>1)对象方法<ul><li>直接声明在类中的函数，自带一个self参数；</li><li>特点：对象方法需要通过’对象.函数名()’的方式来调用；</li><li>通过对象调用对象方法的时候，self不需要传参；系统会自动将当前对象传给self(谁调用传给谁)</li></ul></li><li>强调：不要用类去调用对象方法；失去了self的意义</li></ul><hr><h3 id="四、init方法"><a href="#四、init方法" class="headerlink" title="四、init方法"></a>四、init方法</h3><hr><h4 id="1-什么是init方法"><a href="#1-什么是init方法" class="headerlink" title="1. 什么是init方法"></a>1. 什么是init方法</h4><ul><li><code>__init__</code>：是类中的一个魔法方法，在创建对象的时候会被自动调用</li><li>创建对象做的工作：<ul><li>1)开辟空间，创建对象</li><li>2)用创建好的对象去调用init方法(做一些初始化的操作)</li><li>3)返回对象</li></ul></li></ul><hr><h3 id="五、类中的属性"><a href="#五、类中的属性" class="headerlink" title="五、类中的属性"></a>五、类中的属性</h3><hr><h4 id="1-类中的属性：对象属性、字段"><a href="#1-类中的属性：对象属性、字段" class="headerlink" title="1. 类中的属性：对象属性、字段"></a>1. 类中的属性：对象属性、字段</h4><ul><li>1)字段：<ul><li>a.声明在类中、函数的外面的变量就是类的字段</li><li>b.怎么使用：通过’类.字段’的方式去使用</li><li>c.什么时候用：属性值不会因为对象不同而不一样，这样的属性就声明成字段</li></ul></li><li>对象属性：<ul><li>a.怎么声明：以’self.属性名=值’的方式声明在<code>__init__</code>方法中</li><li>b.怎么使用：通过’对象.属性名’的方式去使用</li><li>c.什么时候用：属性值会因为对象不同而不一样，这样的属性就声明成对象属性</li></ul></li><li>如果init方法中除了self以外还有其他的参数，需要通过构造方法来给<code>__init__</code>方法传参</li><li>重写<code>__repr__</code>方法，来定制对象的打印格式(默认是打印对象地址)-要求返回值必须是字符串</li></ul><hr><h3 id="六、对象属性的增删改查"><a href="#六、对象属性的增删改查" class="headerlink" title="六、对象属性的增删改查"></a>六、对象属性的增删改查</h3><hr><h4 id="1-对象属性"><a href="#1-对象属性" class="headerlink" title="1. 对象属性"></a>1. 对象属性</h4><ul><li>python中对象属性支持增删改查操作</li></ul><hr><h4 id="2-查：获取对象属性的值"><a href="#2-查：获取对象属性的值" class="headerlink" title="2. 查：获取对象属性的值"></a>2. 查：获取对象属性的值</h4><ul><li>1)对象.属性：获取对象指定属性的值，如果属性不存在，会报错</li><li>2)<code>getattr(对象, 属性名)</code>：获取对象指定属性的值，如果属性不存在，会报错</li><li>3)<code>getattr(对象,属性名,默认值)</code>：同上，如果属性不存在，不会报错而是返回默认值</li></ul><hr><h4 id="3-增-改：给对象增加属性，或修改对象属性的值"><a href="#3-增-改：给对象增加属性，或修改对象属性的值" class="headerlink" title="3. 增/改：给对象增加属性，或修改对象属性的值"></a>3. 增/改：给对象增加属性，或修改对象属性的值</h4><ul><li>1)对象.属性 = 值：当属性不存在就给对象添加属性，如果存在则修改属性的值</li><li>2)<code>setattr(对象,属性名,值)</code>：同上</li></ul><hr><h4 id="4-删：删除对象属性"><a href="#4-删：删除对象属性" class="headerlink" title="4. 删：删除对象属性"></a>4. 删：删除对象属性</h4><ul><li>1)del 对象.属性：删除对象指定的属性的值</li><li>2)<code>delattr(对象,属性名)</code></li><li>注意：属性的增删改查只针对当前对象，不会作用于其他对象</li><li>slots魔法：可以通过给类的<code>__slots__</code>字段赋值，来约束当前类的对象最多有哪些属性</li></ul><hr><h3 id="七、内置类属性"><a href="#七、内置类属性" class="headerlink" title="七、内置类属性"></a>七、内置类属性</h3><hr><h4 id="1-什么是内置类属性"><a href="#1-什么是内置类属性" class="headerlink" title="1. 什么是内置类属性"></a>1. 什么是内置类属性</h4><ul><li>创建类的时候，系统自动为这个类提供的属性</li><li><code>1.__name__</code>：类的字段，获取类的名字</li><li><code>2.__doc__</code>：类的字段，获取类的说明文档</li><li><code>3.__class__</code>：对象属性，通过对象来用，获取对象对应的类</li><li><code>4.__dict__</code>：<ul><li>类的字段，获取类中的字段(用得少)</li><li>对象属性，获取对象所有的属性和其对应的值，以字典的形式返回(用得多)</li><li>注意：如果给类的<code>__slots__</code>属性赋了值，那么这个类的对象就不能使用<code>__dict__</code>去获取所有的属性</li></ul></li><li><code>__module__</code>：类的字段，获取类所在的模块(类是在哪个py文件中声明的)</li><li><code>__bases__</code>：类的字段，获取当前类的父类</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2019/07/15/day13-%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/07/15/day13-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中如何捕获异常和抛出异常。</p><a id="more"></a><h2 id="day13-异常"><a href="#day13-异常" class="headerlink" title="day13-异常"></a>day13-异常</h2><hr><h3 id="一、异常捕获"><a href="#一、异常捕获" class="headerlink" title="一、异常捕获"></a>一、异常捕获</h3><hr><h4 id="1-捕获异常"><a href="#1-捕获异常" class="headerlink" title="1. 捕获异常"></a>1. 捕获异常</h4><ul><li>当程序发生异常时，默认情况下程序会崩溃，不能接着往后执行，捕获异常就是让程序发生异常时不会崩溃，能够接着执行，一般在明明知道代码可能会出现异常，但是又不能通过修改代码去避免，这个时候就可以通过异常捕获去处理异常</li></ul><hr><h4 id="2-捕获异常的语法"><a href="#2-捕获异常的语法" class="headerlink" title="2. 捕获异常的语法"></a>2. 捕获异常的语法</h4><ul><li><p>1)语法1：捕获所有的异常</p><ul><li><blockquote><p>try:</p><p>​    代码段1</p><p>except:</p><p>​    代码段2</p><p>try,except：关键字，固定写法</p><p>代码段1：需要捕获异常的一条或多条语句</p><p>代码段2：出现异常后需要去执行的一条或多条语句</p><p>执行过程：先执行代码段1，如果执行代码段1的时候出现异常，程序不会崩溃，而是直接执行代码段2；如果代码段1没有出现异常，不会执行代码段2</p></blockquote></li></ul></li><li><p>2)语法2：</p><ul><li><blockquote><p>try:</p><p>​    代码段1</p><p>except 异常类型:</p><p>​    代码段2</p><p>执行过程：先执行代码段1，如果执行的时候出现异常，判断异常类型和except后面的类型是否一致，如果一致，则程序不崩溃，直接执行代码段2，如果不一致，程序直接崩溃</p></blockquote></li></ul></li><li><p>3)语法3：</p><ul><li><blockquote><p>try:</p><p>​    代码段1</p><p>except (异常类型1, 异常类型2,…):</p><p>​    代码段2</p></blockquote></li></ul></li><li><p>4)语法4：</p><ul><li><blockquote><p>try:</p><p>​    代码段1</p><p>except 异常类型1:</p><p>​    代码段11</p><p>except 异常类型2:</p><p>​    代码段22</p><p>…</p></blockquote></li></ul></li></ul><hr><h4 id="3-finally"><a href="#3-finally" class="headerlink" title="3. finally"></a>3. finally</h4><ul><li>捕获异常的最后可以添加一个finally，finally后面的代码段在任何时候都会执行</li><li>1)try后面的代码段没有出现异常，finally会执行</li><li>2)try后面的代码段出现异常，被捕获到，finally会执行</li><li>3)try后面的代码段出现异常，没有被捕获到，finally会执行</li></ul><hr><h4 id="4-抛出异常"><a href="#4-抛出异常" class="headerlink" title="4. 抛出异常"></a>4. 抛出异常</h4><ul><li>让代码在某种情况下主动崩溃</li><li>raise 异常类型</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 捕获异常 </tag>
            
            <tag> 抛出异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作和json数据</title>
      <link href="/2019/07/13/day12-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8Cjson%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/07/13/day12-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8Cjson%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的文件操作以及json数据格式。</p><a id="more"></a><h2 id="day12-文件操作和json数据"><a href="#day12-文件操作和json数据" class="headerlink" title="day12-文件操作和json数据"></a>day12-文件操作和json数据</h2><hr><h3 id="一、文件操作"><a href="#一、文件操作" class="headerlink" title="一、文件操作"></a>一、文件操作</h3><hr><h4 id="1-数据持久化"><a href="#1-数据持久化" class="headerlink" title="1. 数据持久化"></a>1. 数据持久化</h4><ul><li><p>计算机内存分为硬盘和运行内存</p></li><li><p>存储到本地文件中的数据，就是存储在硬盘中的数据，就能持久化</p></li><li><p>编程中常用的数据持久化文件：</p><ul><li><p>txt文件</p></li><li><p>二进制文件(图片、音频、视频、压缩文件)</p></li><li><p>json文件</p></li><li><p>数据库文件(.db、.sql)</p></li><li><p>plist文件</p></li></ul></li><li><p>数据持久化三步走：</p><ul><li>a.需要持久化的数据保存在本地文件中</li><li>b.需要数据的时候去文件中读数据</li><li>c.数据发生改变后将最新的数据写入文件中</li></ul></li></ul><hr><h4 id="2-文件操作-对文件内容的操作"><a href="#2-文件操作-对文件内容的操作" class="headerlink" title="2. 文件操作 - 对文件内容的操作"></a>2. 文件操作 - 对文件内容的操作</h4><ul><li><p>基本步骤：打开文件；读/写操作；关闭文件</p></li><li><p>1)打开文件：</p><ul><li><p><code>open(file, mode=&#39;r&#39;, encoding=None)</code>：打开指定文件，返回文件对象</p></li><li><p>file：字符串，需要打开的文件的路径，可以是绝对路径，也可以是相对路径</p><ul><li><p>绝对路径：文件在电脑上的完整路径</p></li><li><blockquote><p>相对路径：./(当前目录，当前py文件所在的目录)，可以省略</p><p>​                   ../(当前目录的上层目录)</p></blockquote></li></ul></li><li><p>mode：字符串，决定文件的打开方式；打开方式决定了打开文件后支持的操作</p><ul><li>‘r’：默认值，只读，读出来的数据就是字符串类型</li><li>‘w’：只写；只能将字符串写入文件(先删除原文件内容，再写)</li><li>‘rb/br’：二进制只读；以二进制的格式读</li><li>‘wb/bw’：二进制只写；只能将二进制数据写入文件</li><li>‘a’：只写；追加字符串内容(保留原文件内容)</li><li>‘ab/ba’：二进制只写；追加二进制内容(保留原文件内容)</li></ul></li><li><p>encoding：设置文件的编码方式，固定写’utf-8’；只针对文本文件有效</p></li><li><p>注意：</p><ul><li>只有文本操作才能设置编码方式(二进制不行)</li><li>文本文件在读和写(或编码和解码)的方式必须一致</li><li>windows默认的是’gbk’</li></ul></li></ul></li><li><p>2)操作文件：</p><ul><li>a.读操作：获取文件中的内容<ul><li>文件对象.read()：获取文件中所有的内容，会返回文件中的内容</li><li>文件对象.readline()：读一行内容(从读写位置到一行结尾)</li></ul></li><li>b.写操作<ul><li>文件对象.write(写的内容)：将指定的内容写入文件中</li></ul></li></ul></li><li><p>3)关闭文件</p><ul><li>文件对象.close()</li></ul></li><li><p>4)移动读写的位置(移动光标)</p><ul><li>文件对象.seek(0)：将读写位置移动到文件开头</li></ul></li></ul><hr><h3 id="二、二进制文件的操作"><a href="#二、二进制文件的操作" class="headerlink" title="二、二进制文件的操作"></a>二、二进制文件的操作</h3><hr><h4 id="1-二进制文件有哪些"><a href="#1-二进制文件有哪些" class="headerlink" title="1. 二进制文件有哪些"></a>1. 二进制文件有哪些</h4><ul><li>常见的二进制文件：图片文件、音频文件、视频文件、压缩文件等</li><li>不是只有二进制文件才支持’b’操作(rb、wb、ab)，但是二进制文件只能采用’b’操作</li><li>注意：所有带’b’的操作都不能设置encoding</li></ul><hr><h4 id="2-文件不存在"><a href="#2-文件不存在" class="headerlink" title="2. 文件不存在"></a>2. 文件不存在</h4><ul><li>如果以读的方式打开一个不存在的文件，程序会报错</li><li>如果以写的方式打开一个不存在的文件，不会报错，而是自动创建这个文件</li></ul><hr><h4 id="3-打开文件的简写"><a href="#3-打开文件的简写" class="headerlink" title="3. 打开文件的简写"></a>3. 打开文件的简写</h4><ul><li>1)语法：<ul><li>with open(‘文件路径’, ‘读写方式’, encoding=’编码方式’) as 文件对象：文件域(操作文件)</li></ul></li><li>2)说明：以这种方式打开的文件，在文件域结束后，文件会自动关闭</li></ul><hr><h3 id="三、json数据"><a href="#三、json数据" class="headerlink" title="三、json数据"></a>三、json数据</h3><hr><h4 id="1-什么是json数据：满足json格式的数据"><a href="#1-什么是json数据：满足json格式的数据" class="headerlink" title="1. 什么是json数据：满足json格式的数据"></a>1. 什么是json数据：满足json格式的数据</h4><ul><li>1)json格式：<ul><li>a.一个json有且只有一个数据</li><li>b.这个数据必须是json支持的数据类型对应的数据</li></ul></li><li>2)json支持的数据类型<ul><li>a.数据类型：包含所有的数字</li><li>b.字符串：使用双引号引起来的字符集，支持转义字符和编码字符</li><li>c.布尔：只有true和false两个值</li><li>d.数组：相当于python中的列表</li><li>e.字典：相当于python中的字典，但key只能是字符串</li><li>f.null：相当于python中的None，表示空</li></ul></li></ul><hr><h4 id="2-json转python"><a href="#2-json转python" class="headerlink" title="2. json转python"></a>2. json转python</h4><ul><li>1)转换关系</li></ul><table><thead><tr><th>json</th><th>python</th></tr></thead><tbody><tr><td>数字类型</td><td>int或float</td></tr><tr><td>字符串</td><td>str，双引号可能会变成单引号</td></tr><tr><td>布尔</td><td>bool，true-&gt;True,false-&gt;False</td></tr><tr><td>数组</td><td>list，内容也会跟着变</td></tr><tr><td>字典</td><td>dict，内容也会跟着变</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><ul><li>2)方法<ul><li><code>json.loads(字符串)</code>：将json格式的字符串转换成对应的python的数据</li><li>注意：字符串的内容必须是json格式的数据</li></ul></li></ul><hr><h4 id="3-python转json"><a href="#3-python转json" class="headerlink" title="3. python转json"></a>3. python转json</h4><ul><li>1)转换关系</li></ul><table><thead><tr><th>python</th><th>json</th></tr></thead><tbody><tr><td>int/float</td><td>数字</td></tr><tr><td>str</td><td>字符串，单引号变双引号</td></tr><tr><td>bool</td><td>布尔，True-&gt;true,False-&gt;false</td></tr><tr><td>list/tuple</td><td>数组</td></tr><tr><td>dict</td><td>字典</td></tr><tr><td>None</td><td>null</td></tr></tbody></table><ul><li>2)方法<ul><li><code>json.dumps(python数据)</code>：将数据转换成json格式的字符串</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件操作 </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高阶函数</title>
      <link href="/2019/07/11/day11-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
      <url>/2019/07/11/day11-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的高阶函数、迭代器和生成器、生产式以及模块的使用。</p><a id="more"></a><h2 id="day11-高阶函数"><a href="#day11-高阶函数" class="headerlink" title="day11-高阶函数"></a>day11-高阶函数</h2><hr><h3 id="一、函数作为变量"><a href="#一、函数作为变量" class="headerlink" title="一、函数作为变量"></a>一、函数作为变量</h3><hr><h4 id="1-函数调用表达式"><a href="#1-函数调用表达式" class="headerlink" title="1. 函数调用表达式"></a>1. 函数调用表达式</h4><ul><li>就是调用函数的语句</li><li>普通值能做的事情函数调用表达式都可以做</li></ul><hr><h4 id="2-函数作为变量"><a href="#2-函数作为变量" class="headerlink" title="2. 函数作为变量"></a>2. 函数作为变量</h4><ul><li><p>!!python中声明函数本质就是声明一个类型是function的变量，函数名就是变量名</p></li><li><p>变量能做的事情函数都可以做</p></li><li><p>1)一个变量可以给另外一个变量赋值</p></li><li><p>2)给变量重新赋值</p></li><li><p>3)变量作为容器的元素</p></li><li><p>4)变量可以作为函数的参数</p><ul><li><p>一个函数可以作为另外一个函数的参数</p></li><li><p>如果一个函数的参数也是函数，这种函数叫做实参高阶函数</p></li><li><blockquote><p>sort和sorted</p><p>这两个函数是实参高阶函数，里面有个参数key要求传一个函数</p><p>key参数对应的函数是用来决定排序规则：</p><p>—函数需要一个参数和一个返回值</p><p>—它的参数代表排序的序列的元素，返回值是比较对象</p><p>实参高阶函数：列表.sort()、sorted()、max()、min()</p></blockquote></li></ul></li><li><p>5)变量可以作为函数的返回值</p><ul><li>一个函数的返回值如果也是一个函数，这个函数就是返回值高阶函数</li></ul></li></ul><hr><h3 id="二、迭代器"><a href="#二、迭代器" class="headerlink" title="二、迭代器"></a>二、迭代器</h3><hr><h4 id="1-什么是迭代器-iter"><a href="#1-什么是迭代器-iter" class="headerlink" title="1. 什么是迭代器(iter)"></a>1. 什么是迭代器(iter)</h4><ul><li>迭代器是容器型数据类型(序列)，可变(但不支持增删改)、有序(但不支持下标操作)</li><li>保存在迭代器中的元素，只能取，且取出来后迭代器中就不再保存，也不能再往迭代器中添加元素</li><li>迭代器没有对应格式的数据，迭代器的产生只能通过：将其他序列转换成迭代器，或生成器</li></ul><hr><h4 id="2-获取迭代器中的元素"><a href="#2-获取迭代器中的元素" class="headerlink" title="2. 获取迭代器中的元素"></a>2. 获取迭代器中的元素</h4><ul><li>不管什么样的方式去获取迭代器中的元素，都是获取一个就会少一个</li><li>1)获取单个元素：next(迭代器)<ul><li>获取迭代器中最顶部(第一个)的元素</li></ul></li><li>2)遍历：一个一个取，获取迭代器中所有的元素</li></ul><hr><h3 id="三、生成器"><a href="#三、生成器" class="headerlink" title="三、生成器"></a>三、生成器</h3><hr><h4 id="1-什么是生成器"><a href="#1-什么是生成器" class="headerlink" title="1. 什么是生成器"></a>1. 什么是生成器</h4><ul><li>生成器本质就是迭代器：获取元素和迭代器一样</li><li>调用函数体中有yield关键字的函数，就可以得到一个生成器</li></ul><hr><h4 id="2-yield"><a href="#2-yield" class="headerlink" title="2. yield"></a>2. yield</h4><ul><li>yield只能出现在函数体中</li><li>调用有yield关键字的函数，不会再执行函数体，也不会获取返回值，而是得到一个生成器</li></ul><hr><h4 id="3-生成器怎么产生数据"><a href="#3-生成器怎么产生数据" class="headerlink" title="3. 生成器怎么产生数据"></a>3. 生成器怎么产生数据</h4><ul><li>看一个生成器能够产生几个数据，就看执行完生成器对应的函数会遇到几次yield，yield后面的值就是生成器能产生的数据</li></ul><hr><h4 id="4-生成器生成数据的原理"><a href="#4-生成器生成数据的原理" class="headerlink" title="4. 生成器生成数据的原理"></a>4. 生成器生成数据的原理</h4><ul><li>生成器不会同时将所有的元素保存起来，而是需要数据的时候临时产生数据</li><li>获取生成器元素的时候，就去执行生成器对应的函数的函数体，从前往后执行，直到遇到yield为止，并且将yield后面的值作为结果，同时保存结束位置，下次获取下一个元素的时候，接着上次结束的位置往后执行，直到遇到下一个yield，以此类推…</li><li>如果执行到函数结束都没有遇到yield，next函数会报StopIteration错误</li></ul><hr><h3 id="四、生成式"><a href="#四、生成式" class="headerlink" title="四、生成式"></a>四、生成式</h3><hr><h4 id="1-什么是生成式"><a href="#1-什么是生成式" class="headerlink" title="1. 什么是生成式"></a>1. 什么是生成式</h4><ul><li><p>生成式本质就是生成器</p></li><li><p>语法1：</p><ul><li><p>(表达式 for 变量 in 序列)：创建一个生成器</p></li><li><blockquote><p>展开成生成器：</p><p>def func():</p><p>​       for 变量 in 序列:</p><p>​              yield 表达式</p></blockquote></li><li><p>[表达式 for 变量 in 序列] - 将生成式对应的生成器转换成列表</p></li></ul></li><li><p>语法2：</p><ul><li><p>(表达式 for 变量 in 序列 if 条件语句)：创建一个生成器</p></li><li><blockquote><p>展开成生成器：</p><p>def func():</p><p>​       for 变量 in 序列:</p><p>​              if 条件语句：</p><p>​                    yield 表达式</p></blockquote></li></ul></li></ul><hr><h3 id="五、模块的使用"><a href="#五、模块的使用" class="headerlink" title="五、模块的使用"></a>五、模块的使用</h3><hr><h4 id="1-什么是模块"><a href="#1-什么是模块" class="headerlink" title="1. 什么是模块"></a>1. 什么是模块</h4><ul><li>在实际开发中，一个项目会分为多个模块</li><li>一个python文件就是一个模块</li></ul><hr><h4 id="2-多个模块怎么协作：导入模块"><a href="#2-多个模块怎么协作：导入模块" class="headerlink" title="2. 多个模块怎么协作：导入模块"></a>2. 多个模块怎么协作：导入模块</h4><ul><li>1)import 模块名：在当前模块中导入指定模块，导入后可以使用指定模块中所有的全局变量，必须以’模块名.变量’的方式去使用</li><li>2)from 模块名 import 全局变量1，全局变量2…：导入指定模块中指定的全局变量，被导入的全局变量在当前模块中可以直接使用</li><li>3)重命名：<ul><li>import 模块名 as 新模块名：模块重命名，通过新模块名来使用模块</li><li>from 模块名 import 全局变量1 as 新变量1，全局变量2 as 新变量2…：变量重命名</li></ul></li><li>4)通配符：from 模块名 import *：导入模块中所有的全局变量，使用的时候直接用</li></ul><hr><h4 id="3-导入模块的原理"><a href="#3-导入模块的原理" class="headerlink" title="3. 导入模块的原理"></a>3. 导入模块的原理</h4><ul><li>当执行导入模块的代码时，实质会执行被导入的模块对应的py文件</li><li>将不希望被别的模块执行的代码放到下面的if语句中<ul><li><code>if __name__ == &#39;__main__&#39;</code></li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高阶函数 </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数02</title>
      <link href="/2019/07/09/day10-%E5%87%BD%E6%95%B0-02/"/>
      <url>/2019/07/09/day10-%E5%87%BD%E6%95%B0-02/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的函数的返回值、匿名函数以及递归函数。</p><a id="more"></a><h2 id="day10-函数-02"><a href="#day10-函数-02" class="headerlink" title="day10-函数-02"></a>day10-函数-02</h2><hr><h3 id="一、函数的返回值"><a href="#一、函数的返回值" class="headerlink" title="一、函数的返回值"></a>一、函数的返回值</h3><hr><h4 id="1-什么是返回值"><a href="#1-什么是返回值" class="headerlink" title="1. 什么是返回值"></a>1. 什么是返回值</h4><ul><li>概念：返回值就是函数返回给函数调用者的值</li><li>语法：返回值就是return后面的值</li><li>获取返回值：返回值就是函数调用表达式的值</li></ul><hr><h4 id="2-return"><a href="#2-return" class="headerlink" title="2. return"></a>2. return</h4><ul><li>1)什么是return<ul><li>是一个关键字，只能出现在函数体中</li></ul></li><li>2)return作用<ul><li>a.结束函数：执行函数体时，一旦遇到return，函数直接结束</li><li>b.将函数内部的数据传到外部：return 需要返回的数据</li></ul></li><li>说明<ul><li>看一个函数的返回值是什么，就看执行函数体过程中有没有遇到return，如果遇到return，return后面的值就是函数的返回值</li></ul></li><li>3)什么样的数据应该作为函数的返回值<ul><li>初学者：如果执行完函数会产生新的数据，那么产生的新数据就可以返回；产生几个返回几个；return 返回值1, 返回值2</li></ul></li><li>4)怎么获取函数的返回值<ul><li>获取函数调用表达式的值就是获取函数的返回值</li></ul></li></ul><hr><h4 id="3-函数调用过程-完整版-执行过程"><a href="#3-函数调用过程-完整版-执行过程" class="headerlink" title="3. 函数调用过程(完整版) - 执行过程"></a>3. 函数调用过程(完整版) - 执行过程</h4><ul><li><blockquote><p>1)回到函数调用的位置</p><p>2)传参，用实参给形参赋值</p><p>3)执行函数体</p><p>4)执行完函数体，先确定函数返回值(函数结束：a.执行完函数体的最后一条语句 b.执行过程中遇到return)</p><p>5)回到函数调用的位置(这时函数调用表达式的值才是函数的返回值)，接着往后执行</p></blockquote></li></ul><hr><h4 id="4-函数调用过程中的内存变化"><a href="#4-函数调用过程中的内存变化" class="headerlink" title="4. 函数调用过程中的内存变化"></a>4. 函数调用过程中的内存变化</h4><ul><li>函数调用过程其实是一个压栈的过程<ul><li>每次调用函数，系统都会自动在内存中专门为这个函数开辟一个内存空间，用来保存在函数中声明的变量(形参也是声明在函数中的变量)。当函数调用结束，这个内存区域会自动释放。</li></ul></li></ul><hr><h3 id="二、匿名函数"><a href="#二、匿名函数" class="headerlink" title="二、匿名函数"></a>二、匿名函数</h3><hr><h4 id="1-匿名函数：本质还是函数"><a href="#1-匿名函数：本质还是函数" class="headerlink" title="1. 匿名函数：本质还是函数"></a>1. 匿名函数：本质还是函数</h4><ul><li><blockquote><p>1)语法</p><p>函数名 = lambda 参数列表:返回值</p><p>2)lambda：关键字，固定写法</p><p>参数列表：形参列表，以’参数名1,参数名2,…,’形式</p><p>返回值：写任何有结果的表达式</p><p>3)什么时候使用匿名函数</p><p>a.函数的功能一行代码就可以实现</p><p>b.函数的功能不会重复使用</p></blockquote></li><li><p>注意：匿名函数的函数体只有一条语句，且这条语句的结果就是返回值</p></li><li><p>python中三目运算符</p><ul><li>值1 if 条件语句 else 值2：如果条件语句是True，整个表达式结果是值1，否则就是值2</li></ul></li></ul><hr><h3 id="三、变量的作用域"><a href="#三、变量的作用域" class="headerlink" title="三、变量的作用域"></a>三、变量的作用域</h3><hr><h4 id="1-什么是作用域"><a href="#1-什么是作用域" class="headerlink" title="1. 什么是作用域"></a>1. 什么是作用域</h4><ul><li>声明完变量后，这个变量能够作用的范围就是变量的作用域</li></ul><hr><h4 id="2-全局变量和局部变量"><a href="#2-全局变量和局部变量" class="headerlink" title="2. 全局变量和局部变量"></a>2. 全局变量和局部变量</h4><ul><li>1)全局变量：声明在函数或者类外面的变量都是局部变量<ul><li>全局变量的作用域：从声明开始到整个文件结束</li><li>循环和循环体中声明的变量也是全局变量</li></ul></li><li>2)局部变量：声明在函数中的变量就是局部变量<ul><li>局部变量的作用域：从声明开始到整个函数结束</li></ul></li></ul><hr><h4 id="3-global和nonlocal"><a href="#3-global和nonlocal" class="headerlink" title="3. global和nonlocal"></a>3. global和nonlocal</h4><ul><li>这两个关键字只能在函数体中使用</li><li>1)global：在函数中声明一个全局变量(或去修改一个全局变量的值)<ul><li>global 变量名</li><li>变量名 = 值</li></ul></li><li>nonlocal：在局部的局部中去修改局部变量的值<ul><li>nonlocal 变量名</li><li>变量名 = 值</li></ul></li></ul><hr><h3 id="四、递归函数"><a href="#四、递归函数" class="headerlink" title="四、递归函数"></a>四、递归函数</h3><hr><h4 id="1-什么是递归函数：在函数中调用函数本身，这样的函数就是递归函数"><a href="#1-什么是递归函数：在函数中调用函数本身，这样的函数就是递归函数" class="headerlink" title="1. 什么是递归函数：在函数中调用函数本身，这样的函数就是递归函数"></a>1. 什么是递归函数：在函数中调用函数本身，这样的函数就是递归函数</h4><ul><li>循环能做的事情递归都能做</li><li>1)怎么写递归函数<ul><li>第一步：声明函数(和普通函数一样)</li><li>第二步：找临界值(函数结束的条件)</li><li>第三步：找关系(假设函数的功能已经实现了，找f(n)和f(n-1)的关系)</li><li>第四步：使用f(n-1)去实现f(n)的功能</li></ul></li><li>2)总结：通过for或while循环能做的事情就不要用递归函数</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 匿名函数 </tag>
            
            <tag> 函数的返回值 </tag>
            
            <tag> 递归函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数01</title>
      <link href="/2019/07/07/day9-%E5%87%BD%E6%95%B0-01/"/>
      <url>/2019/07/07/day9-%E5%87%BD%E6%95%B0-01/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中什么是函数、函数如何声明、函数如何调用以及函数的参数。</p><a id="more"></a><h2 id="day9-函数-01"><a href="#day9-函数-01" class="headerlink" title="day9-函数-01"></a>day9-函数-01</h2><hr><h3 id="一、函数基础"><a href="#一、函数基础" class="headerlink" title="一、函数基础"></a>一、函数基础</h3><hr><h4 id="1-什么是函数"><a href="#1-什么是函数" class="headerlink" title="1. 什么是函数"></a>1. 什么是函数</h4><ul><li>函数就是对实现某一特定功能的代码的封装</li></ul><hr><h4 id="2-函数的分类"><a href="#2-函数的分类" class="headerlink" title="2. 函数的分类"></a>2. 函数的分类</h4><ul><li>系统函数：系统自己定义的函数(不需要程序去实现的函数)，程序员直接可以使用</li><li>自定义函数：程序员自己实现的函数</li></ul><hr><h4 id="3-声明函数"><a href="#3-声明函数" class="headerlink" title="3. 声明函数"></a>3. 声明函数</h4><ul><li><p>1)语法</p><ul><li><blockquote><p>def 函数名(参数列表):</p><p>​    函数体</p></blockquote></li></ul></li><li><p>2)说明</p><ul><li><blockquote><p>def：声明函数的关键字</p><p>函数名：和变量名一样，是标识符，不能是关键字(要求)；</p><p>​        PEP8命名规范(所有字母小写，多个单词用下划线隔开)；</p><p>​        见名知义(根据名字能够大概知道函数的功能)；</p><p>(), :    -    固定写法</p><p>参数列表：这儿的参数又叫形参，以’变量名1,变量名2,…’形式出现；形参可以没有，也可以有多个；作用：通过形参可以将函数外面的数据传递到函数里面</p><p>函数体：实现函数功能的一条或多条语句</p></blockquote></li></ul></li><li><p>3)初学声明函数的过程</p><ul><li><blockquote><p>a.确定函数功能</p><p>b.根据功能去确定函数名</p><p>c.确定形参：看实现函数的功能需不需要从外面传数据，需要数据就对应一个参数</p><p>d.实现函数的功能</p><p>e.确定返回值</p></blockquote></li><li><p>注意：声明函数的时候不会执行函数体!只有调用函数的时候才会执行函数体</p></li></ul></li></ul><hr><h4 id="4-函数的调用-同一个函数可以调用多次"><a href="#4-函数的调用-同一个函数可以调用多次" class="headerlink" title="4. 函数的调用 - 同一个函数可以调用多次"></a>4. 函数的调用 - 同一个函数可以调用多次</h4><ul><li><p>调用函数就是使用函数</p></li><li><p>1)语法</p><ul><li>函数名(实参列表)</li></ul></li><li><p>2)说明</p><ul><li><blockquote><p>函数名：必须是已经声明过的函数的函数名</p><p>()：固定写法</p><p>实参列表：实参是给形参赋值的；实参是具体的值，如：数据、已赋值变量</p></blockquote></li></ul></li><li><p>3)函数的调用过程</p><ul><li><blockquote><p>第一步：回到函数声明的位置</p><p>第二步：传参-用实参给形参赋值</p><p>第三步：执行函数体</p><p>第四步：返回值</p><p>第五步：执行完函数体，回到函数调用的位置接着往后执行</p></blockquote></li></ul></li></ul><hr><h3 id="二、函数的参数"><a href="#二、函数的参数" class="headerlink" title="二、函数的参数"></a>二、函数的参数</h3><hr><h4 id="1-位置参数和关键字参数-针对实参"><a href="#1-位置参数和关键字参数-针对实参" class="headerlink" title="1. 位置参数和关键字参数 - 针对实参"></a>1. 位置参数和关键字参数 - 针对实参</h4><ul><li>1)位置参数：调用参数的时候，让实参和形参的位置一一对应</li><li>2)关键字参数：调用函数的时候，以’形参=实参’的形式传参；位置可以乱<ul><li>注意：不管使用哪种方式传参要保证每个参数都有值</li><li>如果既有位置参数，又有关键字参数，位置参数必须在关键字参数前面</li></ul></li></ul><hr><h4 id="2-参数默认值-形参"><a href="#2-参数默认值-形参" class="headerlink" title="2. 参数默认值(形参)"></a>2. 参数默认值(形参)</h4><ul><li>声明函数的时候可以给参数设置默认值，以’形参=值’的方式来设置</li><li>设置了默认值的参数，在调用函数的时候可以不用传参</li><li>有默认值的参数必须放在没有默认值参数的后面</li></ul><hr><h4 id="3-参数类型说明"><a href="#3-参数类型说明" class="headerlink" title="3. 参数类型说明"></a>3. 参数类型说明</h4><ul><li>1)赋默认值</li><li>2)以’形参:类型名’的方式说明类型<ul><li>对参数类型进行说明可以引导函数调用者正确的传参</li><li>也可以让实现函数体的时候有代码提示</li></ul></li></ul><hr><h4 id="4-不定长参数"><a href="#4-不定长参数" class="headerlink" title="4. 不定长参数"></a>4. 不定长参数</h4><ul><li><p>1)声明函数的时候，在参数前面加*，那么这个参数就会变成不定长参数</p><ul><li>不定长参数实质是一个元组，接收到的实参就是元组中的元素</li><li>带一个*的不定长参数，调用的时候需要使用位置参数</li></ul></li><li><p>2)声明函数的时候，在参数前面加**，那么这个参数也会变成不定长参数</p><ul><li>带**的不定长参数实质是一个字典，调用的时候必须使用关键字参数</li></ul></li><li><p>注意：参数中带<em>的参数需要放在不带\</em>参数的后面</p></li><li><p>带一个<em>的需要放在放在带\</em>*的前面</p><ul><li><blockquote><p>def func(<em>args, *</em>kwargs):</p><p>​    pass</p></blockquote></li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数的声明 </tag>
            
            <tag> 函数的调用 </tag>
            
            <tag> 函数的参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列表</title>
      <link href="/2019/07/05/day7-%E5%88%97%E8%A1%A8/"/>
      <url>/2019/07/05/day7-%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的列表的运算、列表相关的函数。</p><a id="more"></a><h2 id="day7-列表"><a href="#day7-列表" class="headerlink" title="day7-列表"></a>day7-列表</h2><hr><h3 id="一、认识列表"><a href="#一、认识列表" class="headerlink" title="一、认识列表"></a>一、认识列表</h3><hr><h4 id="1-什么是列表-list"><a href="#1-什么是列表-list" class="headerlink" title="1. 什么是列表(list)"></a>1. 什么是列表(list)</h4><ul><li>列表是容器型数据类型(序列)</li><li>特点：可变(支持元素的增删改)、有序(支持下标操作)</li><li>说明：将[]作为容器，里面的元素用,隔开</li></ul><hr><h4 id="2-列表中的元素"><a href="#2-列表中的元素" class="headerlink" title="2. 列表中的元素"></a>2. 列表中的元素</h4><ul><li>任何类型的数据都可以作为列表的元素，如：数字、字符串、列表、字典、元组、函数等</li><li>同一个列表中的不同元素的类型可以不一样</li></ul><hr><h3 id="二、增删改查"><a href="#二、增删改查" class="headerlink" title="二、增删改查"></a>二、增删改查</h3><hr><h4 id="1-查-获取列表中的元素"><a href="#1-查-获取列表中的元素" class="headerlink" title="1. 查 - 获取列表中的元素"></a>1. 查 - 获取列表中的元素</h4><ul><li>获取单个元素：列表[下标]<ul><li>语法和字符串一样</li></ul></li><li>获取部分元素(列表切片)：列表[开始下标:结束下标:步长]<ul><li>列表切片和字符串切片语法一样，但是列表切片结果是一个列表</li><li>空列表：[]</li></ul></li><li>遍历<ul><li>直接遍历：通过for循环取出每一个元素</li><li>通过遍历下标去遍历列表</li></ul></li></ul><hr><h4 id="2-增-在列表中添加元素"><a href="#2-增-在列表中添加元素" class="headerlink" title="2. 增 - 在列表中添加元素"></a>2. 增 - 在列表中添加元素</h4><ul><li>列表.append(元素)：在列表的最后面追加一个元素</li><li>列表.insert(下标,元素)：在列表指定的下标前面插入指定元素</li></ul><hr><h4 id="3-删除-删除列表中的元素"><a href="#3-删除-删除列表中的元素" class="headerlink" title="3. 删除 - 删除列表中的元素"></a>3. 删除 - 删除列表中的元素</h4><ul><li>del 列表[下标]：删除列表中指定下标对应的元素；没有下标则删除整个列表</li><li>列表.remove(元素)：删除列表中第一个指定的元素<ul><li>元素必须在列表中，否则会报错</li></ul></li><li>列表.pop()：取出列表中最后一个元素，返回被取出的数据<ul><li>列表.pop(下标)：取出列表中指定下标的元素，返回被取出的数据</li></ul></li></ul><hr><h4 id="4-改-修改列表中某个元素的值"><a href="#4-改-修改列表中某个元素的值" class="headerlink" title="4. 改 - 修改列表中某个元素的值"></a>4. 改 - 修改列表中某个元素的值</h4><ul><li>列表[下标] = 新值：将列表中指定下标对应的元素设置为新值</li></ul><hr><h3 id="三、列表的运算"><a href="#三、列表的运算" class="headerlink" title="三、列表的运算"></a>三、列表的运算</h3><hr><h4 id="1-数学运算："><a href="#1-数学运算：" class="headerlink" title="1. 数学运算：+, *"></a>1. 数学运算：+, *</h4><ul><li>列表1 + 列表2：将两个列表中的元素合并产生一个新的列表</li><li>列表 * N：将列表中的元素重复N次产生一个新的列表</li></ul><hr><h4 id="2-比较运算："><a href="#2-比较运算：" class="headerlink" title="2. 比较运算：==, !="></a>2. 比较运算：==, !=</h4><ul><li>列表大小没有实际的意义，所以只关心相等和不相等</li></ul><hr><h4 id="3-in-not-in"><a href="#3-in-not-in" class="headerlink" title="3. in / not in"></a>3. in / not in</h4><ul><li>元素 in 列表：判断列表中是否存在指定的元素</li><li>元素 not in 列表：判断列表中是否不存在指定的元素</li></ul><hr><h4 id="4-len-序列"><a href="#4-len-序列" class="headerlink" title="4. len(序列)"></a>4. len(序列)</h4><ul><li>len()：获取指定列表中的个数</li></ul><hr><h4 id="5-list-数据-：将数据转换成列表"><a href="#5-list-数据-：将数据转换成列表" class="headerlink" title="5. list(数据)：将数据转换成列表"></a>5. list(数据)：将数据转换成列表</h4><ul><li>所有的序列都可以转换成列表</li><li>将序列中的元素转换成列表元素</li></ul><hr><h3 id="四、列表函数"><a href="#四、列表函数" class="headerlink" title="四、列表函数"></a>四、列表函数</h3><hr><h4 id="1-内置函数"><a href="#1-内置函数" class="headerlink" title="1. 内置函数"></a>1. 内置函数</h4><ul><li><code>max(序列)、min(序列)、sum(序列)</code></li><li>max、min：序列中元素类型必须一样；序列中元素必须支持比较运算符</li><li>sum：只支持数字序列的求和</li></ul><hr><h4 id="2-列表相关函数"><a href="#2-列表相关函数" class="headerlink" title="2. 列表相关函数"></a>2. 列表相关函数</h4><ul><li>列表.count(元素)：统计列表中指定元素的个数</li><li>列表.extend(序列)：将序列中的元素依次添加到列表的最后</li><li>列表.index(元素)：获取列表中指定元素对应的下标(只获取第一个)<ul><li>注意：元素不存在会报错</li></ul></li><li>列表.reverse()：对原列表倒序，不会产生新列表</li><li>列表.sort()：将列表中元素从小到大排序<ul><li>列表.sort(reverse=True)：将列表中元素从大到小排序</li><li>要求：列表的元素类型必须一样；元素支持比较运算符</li></ul></li><li>列表.clear()：清空列表</li><li>列表.copy()：复制列表中的元素产生一个新的列表，跟列表[:]功能一样<ul><li>注意：这是一个浅拷贝</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 列表 </tag>
            
            <tag> 列表的函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2019/07/03/day6-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/07/03/day6-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的字符串和字符串的操作。</p><a id="more"></a><h2 id="day6-字符串"><a href="#day6-字符串" class="headerlink" title="day6-字符串"></a>day6-字符串</h2><hr><h3 id="一、认识字符串"><a href="#一、认识字符串" class="headerlink" title="一、认识字符串"></a>一、认识字符串</h3><hr><h4 id="1-什么是字符串-str"><a href="#1-什么是字符串-str" class="headerlink" title="1. 什么是字符串(str)"></a>1. 什么是字符串(str)</h4><ul><li>定义：字符串属于容器型数据类型，又叫序列，将引号作为容器，字符是元素</li><li>特点：不可变(字符个数和顺序都不可变)、有序(字符顺序影响值)</li></ul><hr><h4 id="2-字符串中的内容"><a href="#2-字符串中的内容" class="headerlink" title="2. 字符串中的内容"></a>2. 字符串中的内容</h4><ul><li>字符串中的每个基本单元是字符；python中有字符的概念，但是没有字符对应的数据类型</li><li>1)普通字符：如，字母、数字、文字、符号</li><li>2)转义字符：在指定的符号前加\来表示一些具有特殊功能或特殊意义的符号<ul><li><code>\n</code>  -  换行</li><li><code>\t</code>  -  制表符</li><li><code>\&#39;</code>  -  一个单引号</li><li><code>\&quot;</code>  -  一个双引号</li><li><code>\\</code>  -  一个反斜杠 </li></ul></li><li>3)编码字符：在\u后加四位十六进制编码值，表示一个编码值对应的字符</li><li>4)编码：计算机存储字符的时候实质是字符对应的编码值，每个字符编码值是固定的<ul><li>计算机本身只有存储数字的能力，而且存的是补码(二进制)</li><li>字符和字符编码的一一对应关系就叫编码表。常见的编码表：ASCII、Unicode</li><li>python中采用的是Unicode编码，中文范围：4e00-9fa5</li><li><code>chr(编码值)</code> - 获取编码值对应的字符</li><li><code>ord(字符)</code> - 获取字符的编码值</li></ul></li><li>5)阻止转义：在字符串的最前面加r/R可以阻止当前字符串的所有的转义字符转义<ul><li>一个转义字符和一个编码字符长度都是1</li></ul></li></ul><hr><h3 id="二、字符串操作"><a href="#二、字符串操作" class="headerlink" title="二、字符串操作"></a>二、字符串操作</h3><hr><h4 id="1-获取字符"><a href="#1-获取字符" class="headerlink" title="1. 获取字符"></a>1. 获取字符</h4><ul><li><p>获取单个字符</p><ul><li><blockquote><p>a.语法</p><p>字符串[下标] - 获取指定下标对应的字符</p><p>b.说明</p><p>字符串 - 可以是字符串值、字符串变量或结果是字符串的表达式</p><p>[] - 固定写法</p><p>下标 - 又叫索引，字符一旦确定，那么字符串中的每个字符位置就确定了，每个字符都会对应固定的下标来表示字符在字符中的位置</p><p>下标值有两种：0<del>字符串长度-1、-1</del>-字符串的长度</p><p>0对应的是第一个字符，-1对应最后一个字符</p><p>c.注意：下标不能越界</p></blockquote></li></ul></li><li><p>获取部分字符(字符串切片)</p><ul><li><blockquote><p>a.语法</p><p>字符串[开始下标:结束下标:步长] - 从开始下标开始获取，每次增加步长去取下一个字符，直到获取结束下标为止</p><p>b.说明</p><p>字符串 - 字符串值或字符串变量</p><p>[] - 固定写法</p><p>开始下标，结束下标 - 范围内下标值</p><p>步长 - 整数</p><p>c.注意</p><p>结束下标对应的字符永远都取不到</p><p>当步长为正，开始下标到结束下标从前往后取，这时开始下标对应的字符必须在结束下标对应的字符的前面；否则取到的是空串</p><p>当步长为负，开始下标到结束下标从后往前取，这时开始下标对应的字符必须在结束下标对应的字符的后面；否则取到的是空串</p><p>获取部分下标可以越界</p></blockquote></li></ul></li><li><p>省略部分内容</p><ul><li>a)省略步长 - 默认步长为1</li><li>字符串[开始下标:结束下标]</li><li>b)省略开始下标</li><li>字符串[:结束下标:步长] / 字符串[:结束下标]</li><li>步长为正：从第一个字符开始往后取；步长为负：从最后一个字符往前取</li><li>c)省略结束下标</li><li>字符串[开始下标::步长] / 字符串[开始下标:]</li><li>步长为正：从开始下标往后取到最后一个字符；步长为负：从开始下标往前取到第一个字符</li><li>d)省略下标</li><li>字符串[::步长] / 字符串[:]</li></ul></li><li><p>遍历字符串</p><ul><li><blockquote><p>a)直接遍历拿到每个字符<br>for 变量 in 字符串:</p><p>​    循环体</p><p>b)通过遍历下标来遍历字符串</p><p><code>len(字符串)</code> - 获取字符串的长度</p></blockquote></li></ul></li></ul><hr><h3 id="三、字符串运算"><a href="#三、字符串运算" class="headerlink" title="三、字符串运算"></a>三、字符串运算</h3><hr><h4 id="1-数学运算："><a href="#1-数学运算：" class="headerlink" title="1. 数学运算：+, *"></a>1. 数学运算：+, *</h4><ul><li>1)字符串1 + 字符串2 - 将两个字符串拼接在一起产生一个新的字符串</li><li>注意：字符串只能和字符串相加</li><li>2)字符串 * N - 字符串重复N次产生一个新的字符串</li></ul><hr><h4 id="2-比较运算"><a href="#2-比较运算" class="headerlink" title="2. 比较运算"></a>2. 比较运算</h4><ul><li>1)比较相等：==, !=</li><li>2)比较大小：&gt;, &lt;, &lt;=, &gt;=</li><li>比较字符串中每一对字符的编码值大小，如果相等就继续比较下一对，直到一对不相等为止</li><li>应用：判断一个字符是否是大写字母，是否是小写字母，是否是中文，是否是数字等…</li></ul><hr><h4 id="3-in-not-in"><a href="#3-in-not-in" class="headerlink" title="3. in / not in"></a>3. in / not in</h4><ul><li>字符串1 in 字符串2 - 判断字符串2中是否包含字符串1</li><li>字符串1 not in 字符串2 - 判断字符串2中是否不包含字符串1</li></ul><hr><h4 id="4-len"><a href="#4-len" class="headerlink" title="4. len()"></a>4. len()</h4><ul><li><code>len(序列)</code> - 获取序列的长度(序列中元素的个数)</li></ul><hr><h4 id="5-str-数据-将指定数据转换成字符串"><a href="#5-str-数据-将指定数据转换成字符串" class="headerlink" title="5. str(数据) - 将指定数据转换成字符串"></a>5. str(数据) - 将指定数据转换成字符串</h4><ul><li>所有的数据都可以转换成字符串；直接在数据外面加引号</li></ul><hr><h4 id="6-格式字符串：在字符串中用格式占位符来表示字符串中变化的部分"><a href="#6-格式字符串：在字符串中用格式占位符来表示字符串中变化的部分" class="headerlink" title="6. 格式字符串：在字符串中用格式占位符来表示字符串中变化的部分"></a>6. 格式字符串：在字符串中用格式占位符来表示字符串中变化的部分</h4><ul><li>语法：包含格式占位符的字符串 % (格式字符串对应的多个数据)<ul><li>%s - 字符串</li><li>%d - 整数</li><li>%.Nf - 小数，N用来约束小数的位数</li><li>%c - 字符(可以将数字转换成字符)</li></ul></li></ul><hr><h4 id="7-字符串相关的函数"><a href="#7-字符串相关的函数" class="headerlink" title="7. 字符串相关的函数"></a>7. 字符串相关的函数</h4><ul><li><p>格式：字符串.函数名()</p></li><li><p>1)对齐方式</p><ul><li><blockquote><p>字符串.center(宽度, 填充字符) - 居中填充</p><p>字符串.ljust(宽度, 填充字符) - 左对齐填充</p><p>字符串.rjust(宽度, 填充字符) - 右对齐填充</p><p>字符串.zfill(宽度) - 填充0</p></blockquote></li></ul></li><li><p>2)统计个数</p><ul><li>字符串1.count(字符串2) - 统计字符串1中字符串2的个数</li></ul></li><li><p>3)join()函数</p><ul><li>字符串.join(序列) - 将序列中的元素用指定的字符串连接在一起产生一个新的字符串</li><li>注意：序列的元素必须是字符串</li></ul></li><li><p>4)去掉空白符</p><ul><li><blockquote><p>字符串.lstrip() - 去掉字符串左边的空白</p><p>字符串.rstrip() - 去掉字符串右边的空白</p><p>字符串.strip() - 去掉字符串左边和右边的空白</p></blockquote></li></ul></li><li><p>5) 字符串的替换</p><ul><li>字符串.replace(字符串1, 字符串2) - 将字符串中的字符串1替换为字符换2</li></ul></li><li><p>6)字符串切割</p><ul><li>字符串.split(字符串1) - 将字符串按照字符串1进行切割</li><li>结果是一个序列，列表中元素是多个小字符串</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> str </tag>
            
            <tag> 字符串操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环结构</title>
      <link href="/2019/07/01/day4-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2019/07/01/day4-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的for、while循环结构以及continue、break关键字。</p><a id="more"></a><h2 id="day4-循环结构"><a href="#day4-循环结构" class="headerlink" title="day4-循环结构"></a>day4-循环结构</h2><hr><h3 id="一、for循环"><a href="#一、for循环" class="headerlink" title="一、for循环"></a>一、for循环</h3><hr><h4 id="1-什么时候使用循环"><a href="#1-什么时候使用循环" class="headerlink" title="1. 什么时候使用循环"></a>1. 什么时候使用循环</h4><ul><li>代码中需要重复执行某个操作的时候，就可以使用循环</li><li>python中有for循环和while循环</li></ul><hr><h4 id="2-for循环语法"><a href="#2-for循环语法" class="headerlink" title="2. for循环语法"></a>2. for循环语法</h4><ul><li><blockquote><p>for 变量名 in 序列:</p><p>​    循环体</p><p>a.说明</p><p>for，in   -   关键字，固定写法</p><p>:    -    固定写法</p><p>变量名    -    和声明变量时的变量名要求一样</p><p>序列    -    容器型数据，python常见序列有：range、字符串、列表、字典、集合、元组、迭代器、生成器</p><p>循环体    -    和for保持一个缩进的一条或多条语句，会被重读执行的代码</p><p>b.执行过程</p><p>让变量去序列中取值，一个一个的取，取完为止，每取一个值执行一次循环体</p><p>for循环的循环次数由序列中元素的个数来控制</p></blockquote></li></ul><hr><h4 id="3-range-函数-专门产生一定范围的数字序列"><a href="#3-range-函数-专门产生一定范围的数字序列" class="headerlink" title="3. range()函数   -   专门产生一定范围的数字序列"></a>3. <code>range()</code>函数   -   专门产生一定范围的数字序列</h4><ul><li>1) <code>range(n)</code>-产生一个0~n-1的数字序列（整数），n必须是大于0的整数</li><li>2) <code>range(m,n)</code>-产生m~n-1的数字序列，m和n都必须是整数，n必须大于m</li><li>3) <code>range(m,n,step)</code>-从m开始，每次加step，直到n-1</li></ul><hr><h3 id="二、while循环"><a href="#二、while循环" class="headerlink" title="二、while循环"></a>二、while循环</h3><hr><h4 id="1-while循环的语法"><a href="#1-while循环的语法" class="headerlink" title="1. while循环的语法"></a>1. while循环的语法</h4><ul><li><blockquote><p>while 条件语句:</p><p>​    循环体</p><p>a.说明</p><p>while   -   关键字</p><p>条件语句   -   和if后面的条件语句要求一样，任何有结果的表达式，除了赋值语句都可以</p><p>循环体   -   和while保持一个缩进的一条或多条语句</p><p>b.执行过程</p><p>先判断条件语句是否为True，如果是True就执行循环体；执行完循环体，再判断条件是否为True，如果为True又执行循环体；以此类推，直到条件语句结果是False，整个循环结束</p></blockquote></li></ul><hr><h4 id="2-for循环和while循环的使用"><a href="#2-for循环和while循环的使用" class="headerlink" title="2. for循环和while循环的使用"></a>2. for循环和while循环的使用</h4><ul><li>for：当循环次数确定的时候都选择for循环</li><li>while：死循环，循环次数不确定</li></ul><hr><h4 id="3-随机数"><a href="#3-随机数" class="headerlink" title="3. 随机数"></a>3. 随机数</h4><ul><li><code>randint(m,n)</code>-产生一个m~n的随机整数</li></ul><hr><h3 id="三、循环相关的关键字"><a href="#三、循环相关的关键字" class="headerlink" title="三、循环相关的关键字"></a>三、循环相关的关键字</h3><hr><h4 id="1-continue关键字"><a href="#1-continue关键字" class="headerlink" title="1. continue关键字"></a>1. continue关键字</h4><ul><li>continue只能出现在循环体中；当执行循环体遇到continue时，结束当次循环，进入下次循环的判断</li></ul><hr><h4 id="2-break关键字"><a href="#2-break关键字" class="headerlink" title="2. break关键字"></a>2. break关键字</h4><ul><li>break只能出现在循环体中；当执行循环体遇到break，整个循环直接结束</li></ul><hr><h4 id="3-else关键字"><a href="#3-else关键字" class="headerlink" title="3. else关键字"></a>3. else关键字</h4><ul><li><blockquote><p>1) 完整的for循环</p><p>for 变量 in 序列:</p><p>​    循环体</p><p>else:</p><p>​    代码块</p><p>2) 完整的while循环</p><p>while 条件语句:</p><p>​    循环体</p><p>else:</p><p>​    代码块</p><p>当程序自然死亡，会执行和循环相关的else中的代码块；如果循环是因为遇到break结束，就不会执行else中的代码块</p></blockquote></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> for循环 </tag>
            
            <tag> while循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符、数据类型和if语句</title>
      <link href="/2019/06/28/day3-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/06/28/day3-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的的各种运算符、几种常见的数据类型和if语句。</p><a id="more"></a><h2 id="day3-运算符、数据类型和if语句"><a href="#day3-运算符、数据类型和if语句" class="headerlink" title="day3-运算符、数据类型和if语句"></a>day3-运算符、数据类型和if语句</h2><hr><h3 id="一、运算符"><a href="#一、运算符" class="headerlink" title="一、运算符"></a>一、运算符</h3><hr><h4 id="1-数学运算符"><a href="#1-数学运算符" class="headerlink" title="1. 数学运算符"></a>1. 数学运算符</h4><ul><li>+，-，*，/    —    和数学中的加、减、乘、除一样</li><li>%    —    取余，求余数<ul><li>应用1：通过对2取余来判断一个数是偶数还是奇数</li><li>应用2：通过对10取余来获取一个数的个位数</li></ul></li><li>//    —    取整，求商取商的整数部分<ul><li><code>print(5 // 2)    #结果为2</code>    </li></ul></li><li>**    —    求幂运算<ul><li><code>print(9 ** 0.5)    #幂运算可以用来开方</code></li></ul></li></ul><hr><h4 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h4><ul><li>python中有&gt;(大于), &lt;(小于), &gt;=(大于等于), &lt;=(小于等于), ==(等于), !=(不等于)几种比较运算符</li><li>所有比较运算符的的运算结果都是布尔值(True/False)</li><li>python中还可以使用多个比较运算符来表示一个范围</li></ul><hr><h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h4><ul><li>逻辑运算符有：and，or，not</li><li>and(逻辑与运算)：真真为真，其他为假<ul><li>应用：如果需要多个条件同时满足，这个时候条件才用and连接</li></ul></li><li>or(逻辑或运算)：假假为假，其他为真<ul><li>应用：如果多个条件只要有一个条件满足就可以用or将多个条件连接起来</li></ul></li><li>not(逻辑非运算)：结果取反<ul><li>应用：对一个条件进行否定</li></ul></li><li>短路操作：<ul><li>and短路操作：如果and前的结果是False，不会执行and后面的语句，结果直接为False</li><li>or短路操作：如果or前的结果是True，不会执行or后面的语句，结果直接为True</li></ul></li></ul><hr><h4 id="4-赋值运算符"><a href="#4-赋值运算符" class="headerlink" title="4. 赋值运算符"></a>4. 赋值运算符</h4><ul><li>python中有=，+=，-=，/=，<em>=，%=，//=，*</em>=</li><li>赋值符号的左边必须是变量；复合的赋值运算符的左边必须是已经赋值过的变量</li></ul><hr><h4 id="5-运算顺序"><a href="#5-运算顺序" class="headerlink" title="5. 运算顺序"></a>5. 运算顺序</h4><ul><li>数学运算符 &gt; 比较运算符 &gt; 逻辑运算符 &gt; 赋值运算符</li><li>数学运算符中：** &gt; *, /, //, % &gt; +, -</li><li>加()可以改变运算顺序，有()先算口号里的</li></ul><hr><h3 id="二、数字类型"><a href="#二、数字类型" class="headerlink" title="二、数字类型"></a>二、数字类型</h3><hr><h4 id="1-数字类型：整型-int-、浮点型-float-、布尔-bool-、复数-complex"><a href="#1-数字类型：整型-int-、浮点型-float-、布尔-bool-、复数-complex" class="headerlink" title="1. 数字类型：整型(int)、浮点型(float)、布尔(bool)、复数(complex)"></a>1. 数字类型：整型(int)、浮点型(float)、布尔(bool)、复数(complex)</h4><ul><li><p>整型(int)：包含所有的整数</p></li><li><p>python中整数支持二进制、八进制、十进制、十六进制</p><ul><li><blockquote><p>十进制：</p><p>a.基数：0，1，2，3，4，5，6，7，8，9</p><p>b.进位：逢10进1</p><p>c.位权：10的n次方</p><p>d.表示方式：直接写的所有的数字都是10进制</p><p>e.转换方式：直接print打印</p></blockquote></li><li><blockquote><p>二进制：</p><p>a.基数：0，1</p><p>b.进位：逢2进1</p><p>c.位权：2的n次方</p><p>d.表示方式：在二进制数的前面加前缀0b/0B，例如0b110</p><p>e.转换方式：<code>bin()</code>-把其他进制的数转换为二进制</p></blockquote></li><li><blockquote><p>八进制：</p><p>a.基数：0，1，2，3，4，5，6，7</p><p>b.进位：逢8进1</p><p>c.位权：8的n次方</p><p>d.表示方式：在八进制数的前面加前缀0o/0O，例如0o110</p><p>e.转换方式：<code>oct()</code>-把其他进制的数转换为八进制</p></blockquote></li><li><blockquote><p>十六进制：</p><p>a.基数：0，1，2，3，4，5，6，7，8，9，a/A，b/B，c/C，d/D，e/E，f/F</p><p>b.进位：逢16进1</p><p>c.位权：16的n次方</p><p>d.表示方式：在十六进制数前加前缀0x/0X，例如0x110</p><p>e.转换方式：<code>hex()</code>-把其他进制的数转换为十六进制</p></blockquote></li></ul></li><li><p>浮点型(float)：所有的小数对应的类型</p><ul><li>支持科学计数法：3e4，3e-4</li></ul></li><li><p>布尔值(bool)：只有True和False两个值，True实质是1，False实质是0</p></li><li><p>复数(complex)：包括所有由实数和虚数组成的数字，python中用j表示虚部</p><ul><li>python中直接支持复数运算</li></ul></li></ul><hr><h4 id="2-type-函数"><a href="#2-type-函数" class="headerlink" title="2. type()函数"></a>2. type()函数</h4><ul><li><code>type(数据)</code>-返回指定数据对应的类型</li></ul><hr><h4 id="3-类型转换：类型名-数据"><a href="#3-类型转换：类型名-数据" class="headerlink" title="3. 类型转换：类型名(数据)"></a>3. 类型转换：类型名(数据)</h4><ul><li>将指定的数据转换为指定类型，返回新的数据</li><li><code>int()</code>-转换成整型，数字转换成整型只保留整数部分；不是所有的字符串都能转换成整型，只有去掉引号后本身就是一个整数的字符串才可以</li><li><code>float()</code>-转换成浮点型，数字后面加.0；只有去掉引号后本身就是一个数字的才能转换成浮点型</li><li><code>bool()</code>-所有的数据都可以转换成布尔值；所有为0、为空的值会转换成False，其他都是True</li></ul><hr><h3 id="三、if分支结构"><a href="#三、if分支结构" class="headerlink" title="三、if分支结构"></a>三、if分支结构</h3><hr><h4 id="1-if使用的条件"><a href="#1-if使用的条件" class="headerlink" title="1. if使用的条件"></a>1. if使用的条件</h4><ul><li>当某段代码是需要在满足某个条件的时候才会执行，这个时候就会使用if分支结构</li></ul><hr><h4 id="2-怎么使用if"><a href="#2-怎么使用if" class="headerlink" title="2. 怎么使用if"></a>2. 怎么使用if</h4><ul><li><p>语法1</p><ul><li><blockquote><p>if 条件语句:</p><p>​    代码块</p><p>a.说明</p><p>if    -    关键字，固定写法</p><p>条件语句        -    除了赋值语句以外的所有由结果的表达式</p><p>:    -    固定写法</p><p>代码块    -    和if保持一个缩进的一条或多条语句</p><p>b.执行过程</p><p>先判断条件语句是否为True(如果结果不是布尔就先转换成布尔再判断)，如果是True就执行代码块，否则不执行，继续执行后面的代码</p></blockquote></li></ul></li><li><p>语法2</p><ul><li><blockquote><p>if 条件语句:</p><p>​    代码块1</p><p>else:</p><p>​    代码块2</p><p>a.说明</p><p>if    -    和上面的一样</p><p>代码块1   -   和if保持一个缩进的一条或多条语句</p><p>else        -    关键字，固定写法</p><p>代码块2   -   和else保持一个缩进的一条或多条语句</p><p>b.执行过程</p><p>先判断条件语句是否为True(如果不是也要布尔先转换成布尔)，如果是True就执行带买块1，否则就执行代码块2</p></blockquote></li></ul></li><li><p>语法3</p><ul><li><blockquote><p>if 条件语句1:</p><p>​    代码块1</p><p>elif 条件语句2:</p><p>​    代码块2</p><p>…</p><p>else:</p><p>​    代码块3</p><p>a.说明</p><p>elif   -   关键字，固定写法</p><p>b.执行过程</p><p>先判断条件语句1是否为True，如果是True就执行代码块1，然后整个if结束，直接执行其他语句；如果是False，就判断条件语句2是否为True，如果为True就执行代码块2，然后整个if结束；以此类推，如果前面所有条件语句都是False，就只想else中的代码块</p></blockquote></li></ul></li></ul><hr><h4 id="3-if嵌套"><a href="#3-if嵌套" class="headerlink" title="3. if嵌套"></a>3. if嵌套</h4><ul><li>可以在if结构中再嵌套其他的if语句</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运算符 </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> if语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础语法</title>
      <link href="/2019/06/26/day2-pyhton%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/06/26/day2-pyhton%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了Python中的注释、关键字、变量。</p><a id="more"></a><h2 id="day2-Python基础语法"><a href="#day2-Python基础语法" class="headerlink" title="day2-Python基础语法"></a>day2-Python基础语法</h2><hr><h3 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h3><hr><h4 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h4><ul><li>单行注释：开头用#来表示单行注释</li><li>多行注释：在代码块前后用3个单引号或3个双引号表示</li><li>快捷键：ctrl + /</li></ul><hr><h4 id="2-语句"><a href="#2-语句" class="headerlink" title="2. 语句"></a>2. 语句</h4><ul><li>一行一般只写一条语句，结尾不需要分号；需要写多行语句，之间要用分号隔开</li><li>如果语句过长需要多行显示，在换行位置前加一个\。注意：加\不能破坏数据</li></ul><hr><h4 id="3-行和缩进"><a href="#3-行和缩进" class="headerlink" title="3. 行和缩进"></a>3. 行和缩进</h4><ul><li>缩进：python要求一条语句不能随意加空格或制表符</li><li>行：python要求声明函数和类的前后需要2个换行</li></ul><hr><h4 id="4-标识符"><a href="#4-标识符" class="headerlink" title="4. 标识符"></a>4. 标识符</h4><ul><li>作用：是用来给变量、函数或类命名的</li><li>规范：1)由字母、数字和下划线组成；2)不能用数字做开头；3)不能是关键字</li></ul><hr><h4 id="5-关键字-又叫保留字"><a href="#5-关键字-又叫保留字" class="headerlink" title="5. 关键字(又叫保留字)"></a>5. 关键字(又叫保留字)</h4><ul><li>定义：python保留下来有自己的特殊功能或特殊意义的一些标识符</li><li>python中关键字一共有35个<ul><li><code>[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;async&#39;, &#39;await&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</code></li></ul></li></ul><hr><h4 id="6-常见数据及其类型"><a href="#6-常见数据及其类型" class="headerlink" title="6. 常见数据及其类型"></a>6. 常见数据及其类型</h4><ul><li>数字数据(number)：<code>int</code>-整型，<code>float</code>-浮点型</li><li>文本数据(string)：<code>str</code>-字符串</li><li>布尔值(bool)：<code>True</code>-真，<code>False</code>-假</li><li>以及列表(<code>list</code>)、字典(<code>dict</code>)、元组(<code>tuple</code>)、集合(<code>set</code>)、迭代器(<code>iter</code>)、生成器、函数(<code>function</code>)、自定义的类等等</li></ul><hr><h4 id="7-输入和输出函数"><a href="#7-输入和输出函数" class="headerlink" title="7. 输入和输出函数"></a>7. 输入和输出函数</h4><ul><li><code>print()</code>函数：在控制台输出括号里的内容<ul><li>()内可以是数据、运算表达式、变量</li><li>一个<code>print()</code>可以同时打印多个数据，多个数据之间用逗号隔开</li></ul></li><li><code>input()</code>函数：从控制台获取输入的内容，输入以回车结束。将输入的内容返回<ul><li>使用value变量去获取输入的内容：<code>value = input(&#39;请输入年龄:&#39;)</code></li></ul></li></ul><hr><h3 id="二、python变量"><a href="#二、python变量" class="headerlink" title="二、python变量"></a>二、python变量</h3><hr><h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h4><ul><li>定义：程序中需要通过变量来保存数据</li><li>语法：变量名 = 值</li><li>变量名：程序员自己命名，必须是标识符，不能是关键字<ul><li>规范1：所有的字母都要小写，多个单词之间用下划线隔开</li><li>规范2：见名知义，看到变量名就知道变量中保存的是什么数据</li></ul></li><li>=：赋值运算符，左边必须是变量名。将右边的数据赋值给左边的变量</li><li>值：一切有结果的表达式都可作为值，如：数据、运算表达式、函数调用、已赋值过的变量</li></ul><hr><h4 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h4><ul><li>同时声明多个变量赋相同的值<ul><li><code>a = b = c = 10</code></li></ul></li><li>同时声明多个变量赋不同的值<ul><li><code>x, y = 10, 20</code></li></ul></li><li>变量的重新赋值<ul><li><code>x = 100</code></li><li><code>x = 1000</code></li></ul></li><li>声明变量、变量赋值的原理<ul><li>先开辟空间存储数据，然后让变量指向指定的内存区域，重新赋值时就重新开辟一个新的空间存储数据，再让变量指向新的存储区域</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础语法 </tag>
            
            <tag> 变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2019/06/24/day1-markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/06/24/day1-markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要讲了如何用markdown写技术文档。</p><a id="more"></a><h2 id="day1-markdown语法"><a href="#day1-markdown语法" class="headerlink" title="day1-markdown语法"></a>day1-markdown语法</h2><hr><h4 id="1-markdown标题"><a href="#1-markdown标题" class="headerlink" title="1. markdown标题"></a>1. markdown标题</h4><ul><li>使用#标记，1-6个#分别对应1-6级标题</li><li>使用=标记一级标题，-标记二级标题</li></ul><hr><h4 id="2-markdown段落"><a href="#2-markdown段落" class="headerlink" title="2. markdown段落"></a>2. markdown段落</h4><ul><li>在文字的末尾加2个空格表示换行</li><li>在文字的末尾加1个空格表示重新开始一个段落</li><li>段落末尾加上三个以上*或-来表示分割线</li></ul><hr><h4 id="3-markdown字体"><a href="#3-markdown字体" class="headerlink" title="3. markdown字体"></a>3. markdown字体</h4><ul><li>文字两头加上*或_表示斜体</li><li>文字两头加上**或__表示粗体</li><li>文字两头加上***或___表示粗斜体</li><li>文字两头加上~~表示删除线</li><li>文字两头加上<u></u>表示下划线</li></ul><hr><h4 id="4-markdown列表"><a href="#4-markdown列表" class="headerlink" title="4. markdown列表"></a>4. markdown列表</h4><ul><li>在开头使用*或+或-来表示无序列表</li><li>在开头用数字加上.来表示有序列表</li><li>列表也可以进行嵌套使用</li></ul><hr><h4 id="5-markdown区块"><a href="#5-markdown区块" class="headerlink" title="5. markdown区块"></a>5. markdown区块</h4><ul><li>在开头用&gt;表示区块引用</li><li>区块引用可以嵌套，&gt;&gt;表示第一层嵌套，&gt;&gt;&gt;表示第二层</li><li>区块中可以使用列表，列表中也可以使用区块</li></ul><hr><h4 id="6-markdown代码"><a href="#6-markdown代码" class="headerlink" title="6. markdown代码"></a>6. markdown代码</h4><ul><li>在一行代码的前后加上`表示代码</li><li>在代码开头用制表符或4个空格表示代码区块</li><li>在代码前后用分别用```也可以表示代码区块，并在第一个后面可以指定语言</li></ul><hr><h4 id="7-markdown超链接"><a href="#7-markdown超链接" class="headerlink" title="7. markdown超链接"></a>7. markdown超链接</h4><ul><li>使用<a href></a>来完成超链接，[]中是链接名称，()填链接地址</li><li>使用&lt;&gt;来直接表示链接地址</li><li>也可以用变量来表示，文档末尾附带变量地址</li></ul><hr><h4 id="8-markdown图片显示"><a href="#8-markdown图片显示" class="headerlink" title="8. markdown图片显示"></a>8. markdown图片显示</h4><ul><li>通过<img src alt>来显示图片，[]填图片的名称，()填图片的绝对路径或相对路径</li><li>图片链接也可以像超链接那样对图片网址使用变量来表示</li></ul><hr><h4 id="9-markdown表格"><a href="#9-markdown表格" class="headerlink" title="9. markdown表格"></a>9. markdown表格</h4><ul><li>|  表头  |  表头  |  表头  |</li><li>|———:|:———|:——-:|：分别表示右对齐，左对齐，居中对齐</li><li>|单元格|单元格|单元格|</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
